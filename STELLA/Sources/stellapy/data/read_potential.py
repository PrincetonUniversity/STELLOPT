# 
# #================================================================
# # Read phi(t) from ".out" or ".out.h5"
# #================================================================
# 
# # Load modules
# import numpy as np 
# from stellapy.utils import initiate_nesteddict 
# 
# # stellapy.read.phi
# def read_potential(folder, input_file=None):
#     ''' Returns the parameters related to the potential, read from the ".out.nc" file in <folder>.
# 
#     Parameters
#     ----------
#     folder : str
#         Folder where the *out.nc file generated by stella can be found.
#         
#     input_file : str
#         If str:   Specify which *out.nc file needs to be read inside <folder>.
#         If None:  All the *out.nc files in <folder> are read.
#         
#     Returns
#     -------
#     potential : dict[simulation][time, phi2_vs_kxky, phi2]
#     '''
# 
#     # Store the data for the plots in a nested dictionary potential[simulation][time, phi2_vs_kxky, phi2]
#     potential = initiate_nesteddict() 
# 
#     # Get all out.h5 files or out.nc files inside <folder>
#     netcdf_files = get_NetcdfFilesOrReducedFilesInside(folder, input_file)
# 
#     # Read the data
#     for netcdf_file in netcdf_files: 
# 
#         # Read the number of species 
#         # TODO: be able to read multiple species
#         input_parameters = read_basicInputParameters(folder, netcdf_file.split('.out')[0]+'.in')
#         dim_species = input_parameters['nspec']
#         species = [str(i) for i in range(0,dim_species,1)]  #@UnusedVariable
# 
#         # Read the netcdf_file
#         netcdf_data  = read_netcdf(folder, netcdf_file)
#         
#         # Get the simulation identifier
#         input_file = netcdf_file.split(".out")[0] + ".in"
#         simulation = get_simulationIdentifier(folder, input_file)
# 
#         # Add the data to the dictionary
#         if 'time' in potential[simulation].keys():
#             if not set(netcdf_data['vec_time'][1:]).issubset(set(potential[simulation]['time'])): # Sometimes the file is there twice
#                 _add_data_to_existing_data(potential, netcdf_data, simulation) 
#         if 'time' not in potential[simulation].keys():
#             _add_data_to_new_array(potential, netcdf_data, simulation)
# 
# 
#     if len(netcdf_files) > 0:
# 
#         # Put the time axis and vec_kx in an ascending order
#         _fix_time_order(potential)
# 
#         # Put the kx axis and vec_kx in an ascending order
#         _fix_kx_order(potential)
# 
#         # Sum phi2 and heatflux over all (kx,ky)
#         _sum_over_kxky(potential, 'phi2_vs_kxky', 'phi2') 
#         _sum_over_kxky(potential, 'qflx_kxky',    'qflx') 
#         _sum_over_kxky(potential, 'pflx_kxky',    'pflx')
#         _sum_over_kxky(potential, 'vflx_kxky',    'vflx')
#         
#     return potential
# 
# 
# #================================================================
# # Add data to new array
# #================================================================
# 
# def _add_data_to_new_array(potential, netcdf_data, simulation):
#     potential[simulation]['dim']    = netcdf_data['dim_time']-1       
#     potential[simulation]['time']   = netcdf_data['vec_time'][1:] 
#     potential[simulation]['dim_kx'] = netcdf_data['dim_kx']
#     potential[simulation]['vec_kx'] = netcdf_data['vec_kx_stella']
#     potential[simulation]['dim_ky'] = netcdf_data['dim_ky']
#     potential[simulation]['vec_ky'] = netcdf_data['vec_ky']
#     potential[simulation]['phi2_vs_kxky'] = netcdf_data['phi2_vs_kxky'][1:,:,:]  # phi2_vs_kxky(t,theta0,ky) [1:,:,vec_ky.index(ky)]
# 
#     if 'qflx_kxky' in netcdf_data.keys(): 
#         _add_fluxes_to_new_array(potential, netcdf_data, simulation)
# 
# def _add_fluxes_to_new_array(potential, netcdf_data, simulation,):
#     potential[simulation]['time_fluxes'] = netcdf_data['vec_time'][1:] 
#     potential[simulation]['qflx_kxky'] = netcdf_data['qflx_kxky'][1:,0,:,:] # (t,species,theta0,ky)
#     potential[simulation]['pflx_kxky'] = netcdf_data['pflx_kxky'][1:,0,:,:] # (t,species,theta0,ky)
#     potential[simulation]['vflx_kxky'] = netcdf_data['vflx_kxky'][1:,0,:,:] # (t,species,theta0,ky)
# 
# #================================================================
# # Add data tot existing data
# #================================================================
# 
# def _add_data_to_existing_data(potential, netcdf_data, simulation):        
#     potential[simulation]['dim']         += netcdf_data['dim_time']-1       
#     potential[simulation]['time']         = np.concatenate((potential[simulation]['time'], netcdf_data['vec_time'][1:]))
#     potential[simulation]['phi2_vs_kxky'] = np.concatenate((potential[simulation]['phi2_vs_kxky'],netcdf_data['phi2_vs_kxky'][1:,:,:])) 
# 
#     if 'qflx_kxky' in netcdf_data.keys() and 'qflx_kxky' in potential[simulation]:
#         if not set(netcdf_data['vec_time'][1:]).issubset(set(potential[simulation]['time_fluxes'][:])): # Sometimes the file is there twice
#             _add_fluxes_to_existing_fluxes(potential, netcdf_data, simulation)
# 
#     if 'qflx_kxky' in netcdf_data.keys() and 'qflx_kxky' not in potential[simulation]:
#         _add_fluxes_to_new_array(potential, netcdf_data, simulation)
# 
# 
# def _add_fluxes_to_existing_fluxes(potential, netcdf_data, simulation): 
#     potential[simulation]['time_fluxes'] = np.concatenate((potential[simulation]['time_fluxes'], netcdf_data['vec_time'][1:]))
#     potential[simulation]['qflx_kxky']   = np.concatenate((potential[simulation]['qflx_kxky'],netcdf_data['qflx_kxky'][1:,0,:,:]))
#     potential[simulation]['pflx_kxky']   = np.concatenate((potential[simulation]['pflx_kxky'],netcdf_data['pflx_kxky'][1:,0,:,:]))
#     potential[simulation]['vflx_kxky']   = np.concatenate((potential[simulation]['vflx_kxky'],netcdf_data['vflx_kxky'][1:,0,:,:]))    
# 
# 
# #================================================================
# # Put the time axis in ascending order
# #================================================================
# 
# def _fix_time_order(potential):
#     simulations = list(potential.keys())
#     for simulation in simulations:  
#         sorted_indexes = np.argsort(potential[simulation]['time'])
#         potential[simulation]['time'] = potential[simulation]['time'][sorted_indexes]
#         potential[simulation]['phi2_vs_kxky'] = potential[simulation]['phi2_vs_kxky'][sorted_indexes, :, :] 
#         if 'qflx_kxky' in potential[simulation].keys():
#             sorted_indexes = np.argsort(potential[simulation]['time_fluxes'])
#             potential[simulation]['time_fluxes'] = potential[simulation]['time_fluxes'][sorted_indexes]
#             potential[simulation]['qflx_kxky'] = potential[simulation]['qflx_kxky'][sorted_indexes, :, :]
#             potential[simulation]['pflx_kxky'] = potential[simulation]['pflx_kxky'][sorted_indexes, :, :]
#             potential[simulation]['vflx_kxky'] = potential[simulation]['vflx_kxky'][sorted_indexes, :, :]
# 
# #================================================================
# # Put the kx axis in ascending order
# #================================================================
# 
# def _fix_kx_order(potential):
#     simulations = list(potential.keys())
#     for simulation in simulations: 
#         sorted_indexes = np.argsort(potential[simulation]['vec_kx'])
#         potential[simulation]['vec_kx']        = potential[simulation]['vec_kx'][sorted_indexes]
#         potential[simulation]['phi2_vs_kxky']  = potential[simulation]['phi2_vs_kxky'][:, sorted_indexes, :]
# 
#         if 'qflx_kxky' in potential[simulation].keys():
#             potential[simulation]['qflx_kxky'] = potential[simulation]['qflx_kxky'][:, sorted_indexes, :]
#             potential[simulation]['pflx_kxky'] = potential[simulation]['pflx_kxky'][:, sorted_indexes, :]
#             potential[simulation]['vflx_kxky'] = potential[simulation]['vflx_kxky'][:, sorted_indexes, :]
# 
# #================================================================
# # Sum over (kx,ky)
# #================================================================
# 
# def _sum_over_kxky(potential, quantity, summed_quantity):
#     simulations = list(potential.keys())
#     for simulation in simulations: 
#         potential[simulation][summed_quantity] = np.zeros(len(potential[simulation][quantity]))  
#         for i in range(len(potential[simulation][quantity])):
#             potential[simulation][summed_quantity][i] = np.sum(potential[simulation][quantity][i,:,:])
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 


