#!/usr/bin/env python
'''
coilpy is a python library for plasma physics and coil designing.
Mainly for FOCUS related data virtualization.
Written by CaoXiang ZHU (czhu@pppl.gov)

Table of contents:
1. read plasma boundary (FOCUS format);
2. plot the plasma surface (several types plotting);
3. read the poincare plot data generated by GLASS;
4. get the data from a sequence FOCUS run;
5. read coils.xxx file;
6. tansform spline2xyz format data into a coils file;
7. plot the coils;
8. produce an array of color rgb float triplets;
9. expand single coil filament to a rectangle coil;
10. plot plasma surface from VMEC cdf format output file;
11. poincare plotting from OCULUS data;
12. plot coils from FOCUS hdf5 output data;
13. animating the coils evolution from FOCUS hdf5 output data;
14. plot cost function converging curves from FOCUS hdf5 output data;
15. plot plasma and/or Bn shape in hdf5 file;
16. read *.focus file and store a coil object;
17. write coil/focus object data to an external file;
18. map coils in multiple periods;
19. apply coil perturbation in Fourier space;
20. calculate surface normal for a given toroidal surface;
21. convert Fourier coefficients into discritized coils in xyz;
22. read vmec input/output and prepare FOCUS input plasma boundary;
23. plot the hdf5 file from FIELDLINES;
24. compare the variables in two datasets, data1 and data2;
25. calculate the magnetic field at a position in a mgrid file;
26. plot the target/realized Bn distribution on the theta-zeta plane;
27. plot the winding surface;
28. write down coils on a winding surface

'''


#QT_API imcompactible
# only valid for PPPL

import sip
API_NAMES = ["QDate", "QDateTime", "QString", "QTextStream", "QTime", "QUrl", "QVariant"]
API_VERSION = 2
for name in API_NAMES:
    sip.setapi(name, API_VERSION)
from PyQt4.QtCore import *
from PyQt4.QtGui import *
from PyQt4.QtSvg import *
from PyQt4.QtCore import pyqtSignal as Signal
from PyQt4.QtCore import pyqtSlot as Slot


import numpy as np
import matplotlib.pyplot as plt
import xarray as ncdata
from mpl_toolkits.mplot3d import Axes3D
import os.path
from matplotlib import cm
import h5py
from mayavi import mlab
import colorsys
from scipy import optimize
import subprocess
import f90nml

#------------------------------------------
class coil(object):
    '''
    coil class
    '''
    name = 'default_name'
    I = 0.0
    group = 1
    def __init__(self):
        self.x = []
        self.y = []
        self.z = []
    def __del__(self):
        class_name = self.__class__.__name__
        #print class_name, "destroyed" 

#------------------------------------------
class hdf5(object):
    '''
    load hdf5 results
    '''
    def __init__(self, hdf5file):
        self.filename = hdf5file
        try:
            hdf5 = h5py.File(self.filename, 'r')
            self.names = hdf5.keys()
            for name in self.names:
                setattr(self, name, hdf5[name].value)
                if hdf5[name].value.dtype == 'S1': #only for hdf5 string;
                    setattr(self, name, ''.join(hdf5[name].value))
        except IOError:
            print "Error: this is not a valid hdf5 file."
        else:
            print "Read ", len(self.names), " objects in", hdf5
            if hasattr(self, 'version') :
                print "FOCUS version :", self.version
            hdf5.close()
    def __del__(self):
        class_name = self.__class__.__name__
        #print class_name, "destroyed" 

#------------------------------------------
class fourier(object):
    '''
    fourier series class
    x = a0 + a1*cos(t) + a2*cos(2t) + ...+ b1*sin(t) + b2*sin(2t) + ..
    '''
    def __init__(self, FouData):
        assert len(FouData) > 0
        self.ndim = (len(FouData)+1)/2 - 1  #number of Fourier coefficients; 0,1,2,...,Ndim
        self.cos = np.zeros(self.ndim + 1)
        self.sin = np.zeros(self.ndim + 1)

        if len(FouData) == 2*self.ndim + 1: #omit b0
            self.cos[0:self.ndim+1] = FouData[0:self.ndim+1]
            self.sin[1:self.ndim+1] = FouData[self.ndim+1:2*self.ndim + 1]
        elif len(FouData) == 2*self.ndim + 2: #keep b0
            self.cos[0:self.ndim+1] = FouData[0:self.ndim+1]
            self.sin[0:self.ndim+1] = FouData[self.ndim+1:2*self.ndim + 2]
        else:
            print "Error: dimensions not matched. ", len(FouData)

    def disc(self, nseg=100): #discretize the data
        assert self.ndim > 0
        assert nseg > 0
        m = np.arange(self.ndim + 1)
        ang = np.linspace(0, 2*np.pi, nseg)
        x = np.zeros(nseg)
        for ii in range(nseg):
            x[ii] = sum(self.cos * np.cos( m * ang[ii] ) + self.sin * np.sin( m * ang[ii] ))
        return x

    def __del__(self):
        class_name = self.__class__.__name__
        #print class_name, "destroyed" 

#------------------------------------------
class focus(object):
    '''
    class for focus coil mainly containing coil parameters
    '''
    def __init__(self, itype, Npara):
        self.itype = itype
        self.name   = 'coil1'
        self.NS     = 128
        self.I      = 1.0E6
        self.Ic     = 1
        self.L      = 1.0
        self.Lc     = 1
        self.Lc     = 1.0
        if self.itype == 1 :
            self.NF = Npara
            assert self.NF >= 1
            self.xc = np.zeros(self.NF + 1)
            self.xs = np.zeros(self.NF + 1)
            self.yc = np.zeros(self.NF + 1)
            self.ys = np.zeros(self.NF + 1)
            self.zc = np.zeros(self.NF + 1)
            self.zs = np.zeros(self.NF + 1)
    def __del__(self):
        class_name = self.__class__.__name__
        #print class_name, "destroyed" 

#------------------------------------------  1  ----------------------------------------------------
def read_plasma_boundary(filename):
    '''
    The function read plasma.boundary file in FOCUS format and return
    a structured np.array with [n, m, Rbc, Rbs, Zbc, Zbs]
    '''
    with open(filename, 'r') as f:
        line = f.readline() #skip one line
        line = f.readline()
        num = int(line.split()[0]) #harmonics number
        nfp = int(line.split()[1]) #number of field periodicity
        nbn = int(line.split()[2]) #number of Bn harmonics
        plas_data = np.zeros(num, dtype=[('n', np.float64),('m',np.float64), #m,n saving as double
                                         ('Rbc',np.float64), ('Rbs', np.float64),
                                         ('Zbc',np.float64), ('Zbs', np.float64)])
        line = f.readline() #skip one line
        line = f.readline() #skip one line
        for i in range(num):
            line = f.readline()
            plas_data[i] = tuple([float(j) for j in line.split()])
        plas_data['n'] *= nfp

        if nbn>0 :
            bn_data = np.zeros(nbn, dtype=[('n', np.float64),('m',np.float64),
                                           ('bnc', np.float64),('bns',np.float64)])
            line = f.readline() #skip one line
            line = f.readline() #skip one line
            for i in range(nbn):
                line = f.readline()
                bn_data[i] = tuple([float(j) for j in line.split()])
            bn_data['n'] *= nfp
        else :
            bn_data = []        
    print "read {} Fourier harmonics for plasma boundary and {} for Bn distribution in {}."\
        .format(num,nbn,filename)
    return plas_data, bn_data
        
#------------------------------------------  2  ----------------------------------------------------
def plot_plasma_boundary(filename,plottype='cross-section',zeta=0.0, zeta1=2*np.pi, colormap='coolwarm',
                         color=(1,0,0),style='-',width=2.0,lbl='Target boundary',npol=128,ntor=128):
    '''
    plot the plasma boundary;
    plottype:
            cross-section -> 2D plot at zeta plane
            surface       -> 3D surface using matplotlib
            surface3d     -> 3D surface using mayavi
            bnormal       -> 3D surface plot with Bn scalar using mayavi
    '''
    plas, bfou = read_plasma_boundary(filename)
    maxR, minR, maxZ, minZ = 0.0, 999.0, 0.0, 999.0
    if plottype=='cross-section' : #plot cross-section
        npoints = 360 #number of points
        theta = np.linspace(0,2* np.pi, npoints)
        r = np.zeros(npoints)
        z = np.zeros(npoints)
        for ipoint in range(npoints):
            tmpr = plas['Rbc']*np.cos(plas['m']*theta[ipoint]-plas['n']*zeta) + \
                   plas['Rbs']*np.sin(plas['m']*theta[ipoint]-plas['n']*zeta)
            r[ipoint] = np.sum(tmpr) #r value at ipont
            maxR = max(np.sum(tmpr), maxR)
            minR = min(np.sum(tmpr), minR)

            tmpz = plas['Zbc']*np.cos(plas['m']*theta[ipoint]-plas['n']*zeta) + \
                   plas['Zbs']*np.sin(plas['m']*theta[ipoint]-plas['n']*zeta)
            z[ipoint] = np.sum(tmpz) #z value at ipont
            maxZ = max(np.sum(tmpz), maxZ)
            minZ = min(np.sum(tmpz), minZ)
        if plt.get_fignums():
            fig = plt.gcf()
            ax = plt.gca()
        else :
            fig, ax = plt.subplots()
        ax.plot(r, z, color=color,linewidth=width,linestyle=style,label=lbl)
        plt.axis('equal')
        plt.xlabel('R [m]',fontsize=20)
        plt.ylabel('Z [m]',fontsize=20)
        plt.xticks(fontsize=16)
        plt.yticks(fontsize=16)
        plt.tight_layout()
        return maxR, minR, maxZ, minZ
    elif plottype == 'surface' : #plot surface
        if plt.get_fignums():
            fig = plt.gcf()
        else :
            fig = plt.figure()
        ax = fig.gca(projection='3d')
        x=np.zeros((npol+1,ntor+1))
        y=np.zeros((npol+1,ntor+1))
        z=np.zeros((npol+1,ntor+1))
        for i in range(ntor+1):
            ator = zeta + i*(zeta1-zeta)/ntor #zeta
            for j in range(npol+1):
                apol = j*2*np.pi/npol #theta
                tmpr = plas['Rbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Rbs']*np.sin(plas['m']*apol-plas['n']*ator)
                tmpz = plas['Zbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Zbs']*np.sin(plas['m']*apol-plas['n']*ator)
                maxR = max(np.sum(tmpr), maxR)
                minR = min(np.sum(tmpr), minR)
                maxZ = max(np.sum(tmpz), maxZ)
                minZ = min(np.sum(tmpz), minZ)
                x[j,i] = np.sum(tmpr) * np.cos(ator)
                y[j,i] = np.sum(tmpr) * np.sin(ator)
                z[j,i] = np.sum(tmpz)
        ax.plot_surface(x,y,z,color='white')
        #p1 = [x[npol/2  ,ntor/2  ], y[npol/2  ,ntor/2  ], z[npol/2  ,ntor/2  ]]
        #p2 = [x[npol/2+1,ntor/2  ], y[npol/2+1,ntor/2  ], z[npol/2+1,ntor/2  ]]
        #p3 = [x[npol/2  ,ntor/2+1], y[npol/2  ,ntor/2+1], z[npol/2  ,ntor/2+1]]
        #p4 = [x[npol/2+1,ntor/2+1], y[npol/2+1,ntor/2+1], z[npol/2+1,ntor/2+1]]
        return maxR, minR, maxZ, minZ
    elif plottype == 'surface3d' :
        x=np.zeros((npol+1,ntor+1))
        y=np.zeros((npol+1,ntor+1))
        z=np.zeros((npol+1,ntor+1))

        for i in range(ntor+1):
            ator = zeta + (i+0.5)*(zeta1-zeta)/ntor #zeta
            for j in range(npol+1):
                apol = (j+0.5)*2*np.pi/npol #theta
                tmpr = plas['Rbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Rbs']*np.sin(plas['m']*apol-plas['n']*ator)
                tmpz = plas['Zbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Zbs']*np.sin(plas['m']*apol-plas['n']*ator)
                maxR = max(np.sum(tmpr), maxR)
                minR = min(np.sum(tmpr), minR)
                maxZ = max(np.sum(tmpz), maxZ)
                minZ = min(np.sum(tmpz), minZ)
                x[j,i] = np.sum(tmpr) * np.cos(ator)
                y[j,i] = np.sum(tmpr) * np.sin(ator)
                z[j,i] = np.sum(tmpz)                
        #fig = mlab.figure(bgcolor=(1,1,1),fgcolor=(0,0,0),size=(600,600))
        surf = mlab.mesh(x,y,z,color=color, representation = 'surface')
        # Change the visualization parameters.
        #surf.actor.property.interpolation = 'phong'
        #surf.actor.property.specular = 01.0
        #surf.actor.property.specular_power = 100
        #surf.scene.light_manager.light_mode = "vtk"
        return x, y, z
    elif plottype == 'bnormal' :
        x=np.zeros((npol+1,ntor+1))
        y=np.zeros((npol+1,ntor+1))
        z=np.zeros((npol+1,ntor+1))
        targetBn = np.zeros((npol+1,ntor+1))

        for i in range(ntor+1):
            ator = zeta + (i+0.5)*(zeta1-zeta)/ntor #zeta
            for j in range(npol+1):
                apol = (j+0.5)*2*np.pi/npol #theta
                tmpr = plas['Rbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Rbs']*np.sin(plas['m']*apol-plas['n']*ator)
                tmpz = plas['Zbc']*np.cos(plas['m']*apol-plas['n']*ator) + \
                       plas['Zbs']*np.sin(plas['m']*apol-plas['n']*ator)
                tmpb = bfou['bnc']*np.cos(bfou['m']*apol-bfou['n']*ator) + \
                       bfou['bns']*np.sin(bfou['m']*apol-bfou['n']*ator)
                x[j,i] = np.sum(tmpr) * np.cos(ator)
                y[j,i] = np.sum(tmpr) * np.sin(ator)
                z[j,i] = np.sum(tmpz)
                targetBn[j,i] = np.sum(tmpb)
        #fig = mlab.figure(bgcolor=(1,1,1),fgcolor=(0,0,0),size=(600,600))
        mlab.mesh(x,y,z,scalars=targetBn, colormap=colormap)
        return targetBn
    else :
        raise NameError("No such option!")
        print "plottype = cross-section/surface/surface3d/bnormal"
        

#------------------------------------------  3  ----------------------------------------------------
def read_ppfile(ppfile):
    '''
    INPUT : ppfile (string, the poincare plot (pp) binary file path and name)
    OUTPUT: R, Z (list, the two lists represent the data in R and Z)
    DETAIL: This function read a pp file and return the data in two lists, used for GGLASS/FOCUS
            pp file. (The two have slightly differences at the header.)
    '''
    r = np.array([])
    z = np.array([])
    with open(ppfile, 'rb') as f:
        while True:
            head = np.fromfile(f, dtype=np.int32, count=1) #fortran unformatted header
            #detect end of file
            if not head:
                break
            length = head[0]
            #print(length)
            npoints = np.fromfile(f, dtype=np.int32, count=length/4)[0] #length/4 = no. of integers
            #print(npoints)
            nonuse = f.read(8)
            rzdata = np.fromfile(f, dtype=np.float64, count=2*(1+npoints)) #reading all the R,Z data
            #print(len(rzdata))
            rzdata = rzdata.reshape(1+npoints,2)
            r = np.append(r, rzdata[:,0])
            z = np.append(z, rzdata[:,1])
            nouse = f.read(4)  #skip write ender
    return r, z
 
#------------------------------------------  3  ----------------------------------------------------
def sequence_h5_data(prefix, variable, result, istart, istop, istep, itype):
    '''
    INPUT : prefix   (string, the path and prefix, like'./seq.NC')
          : variable (string, the variable name that is varying, like 'Ncoils')
          : result   (string, the result term that want to be plotted, like 'Bnorm')
          : istart   (int   , starting number)
          : istop    (int   , stopping number)
          : istep    (int   , stepp size)
          : ityp     (strung, either "times" or "plus", selecting different loop type)
    OUTPUT: rslt     (list/np.array, rslt[i] = [tau, bnorm])
    DETAIL: This function reads the result data in mulptiple files, used for FOCUS sequence running
    '''
    suffix = '.fo.h5'
    #get number of files and generating looped names
    if itype == 'times':
        N=istop-istart+1
        numbers = [istep**exp for exp in range(istart, istop)]
        numbers.insert(0,0)
    elif itype == 'plus':
        N=(istop-istart)/istep + 1
        numbers = range(istart, istop + istep, istep)
    else:
        raise NameError("Either 'plus' or 'times'")
    filename = [prefix + '=+' + str(x).zfill(6) + suffix for x in numbers]

    rslt = [] #empty list

    for iname in filename:
        with h5py.File(iname,'r') as h5_fid:
            evolution = h5_fid['evolution'].value
            marker = str(h5_fid[variable].value[0])
            tau = evolution[0,:]
            energy = evolution[1,:]
            deriv = evolution[2,:]
            bnorm = evolution[3,:]
            tflux = evolution[4,:]
            ttlen = evolution[5,:]
            rslt.append([tau,bnorm])  #append[tau, bnorm]; will be changed later
    return rslt
#------------------------------------------  4  ----------------------------------------------------
    
def read_coils(filename, filetype='coils'):
    '''
    filename : the path for the coils file
    return an array of coil class;
    '''

    if not os.path.exists(filename) :
        raise IOError ("File not existed. Please check again!")

    Ncoils = 0

    if filetype == 'coils':  # traditional coils.xxx file
        with open(filename,'r') as coilfile: #get each coil segments number
            coilfile.readline()
            coilfile.readline()
            coilfile.readline()
            for line in coilfile:
                if line[0:2] == 'end':
                    break

                if len(line.split()) > 4 :
                    Ncoils = Ncoils + 1
                    continue
        print "Read {} coils in {}.".format(Ncoils, filename)
        coildata = np.ndarray((Ncoils,),dtype=np.object)
        with open(filename,'r') as coilfile: #read coil xyz and I
            coilfile.readline()
            coilfile.readline()
            coilfile.readline()
            icoil = 0
            coildata[0] = coil()
            for line in coilfile:
                linelist = line.split()
                if len(linelist) < 4 :
                    print"End of file or invalid format!"
                    break
                coildata[icoil].x.append(float(linelist[0]))
                coildata[icoil].y.append(float(linelist[1]))
                coildata[icoil].z.append(float(linelist[2]))
                if len(linelist) == 4 :
                    coildata[icoil].I = float(linelist[-1])
                if len(linelist) > 4 :
                    coildata[icoil].name = linelist[-1]
                    #print "get one new coil"
                    icoil = icoil + 1
                    if icoil >= Ncoils :
                        break
                    coildata[icoil] = coil()
                    continue
            if icoil != Ncoils:
                raise ValueError("The number of coils doesn't match!")
    elif filetype == 'focus': # FOCUS format file with Fourier representation
        with open(filename, 'r') as coilfile:
            coilfile.readline()
            Ncoils = int(coilfile.readline())
            #print "Read {} coils.".format(Ncoils)
            coildata = np.ndarray((Ncoils,),dtype=np.object)

            for icoil in range(Ncoils):
                coildata[icoil] = coil()
                coilfile.readline()
                coilfile.readline()

                linelist = coilfile.readline().split()
                coildata[icoil].name = linelist[-1]     # coil name
                coilfile.readline()
                linelist = coilfile.readline().split()
                Nseg = int(linelist[0])+1               # coil No. of segments; extra one for closed curves
                coildata[icoil].I = float(linelist[1])  # coil current
                coilfile.readline()
                NFcoil = int(coilfile.readline())       # No. of Fourier harmonics
                             
                coilfile.readline()
                strlist = coilfile.readline().split() + coilfile.readline().split() # x cos & sin harmonics
                FouData = [float(i) for i in strlist]
                coildata[icoil].x =  fourier(FouData).disc(Nseg) # discretize x
                strlist = coilfile.readline().split() + coilfile.readline().split() # y cos & sin harmonics
                FouData = [float(i) for i in strlist]
                coildata[icoil].y = fourier(FouData).disc(Nseg) # discretize y
                strlist = coilfile.readline().split() + coilfile.readline().split() # z cos & sin harmonics
                FouData = [float(i) for i in strlist]
                coildata[icoil].z = fourier(FouData).disc(Nseg) # discretize z
        
    return(coildata)

#------------------------------------------  5  ----------------------------------------------------
def xyz2coils(xyzname,coilsname):
    '''
    This function read sxyz.dat produced by spline2xyz and then write into a coils file
    INPUT  : xyzname  (string, filename for xyzdata)
    OUTPUT : coilsname(string, filename for coils file)
    '''
    x = []
    y = []
    z = []
    c = []
    n = []
    with open(xyzname, 'r') as xyzfile:
        for line in xyzfile:
            tmp=line.split()
            x.append(float(tmp[0]))
            y.append(float(tmp[1]))
            z.append(float(tmp[2]))
            c.append(float(tmp[3]))
            n.append(int (tmp[-1]))
    num = len(x)
    data = np.zeros(num, dtype=[('xyzc',np.float64,(1,4)), ('n',np.int)])
    for i in range(num):
        data[i] = ([x[i],y[i],z[i],1.0E7], n[i])
    coilnum = set(data['n'])

    with open(coilsname,'w') as coilsfile:
        coilsfile.write('periods 1'+'\n')
        coilsfile.write('begin filament'+'\n')
        coilsfile.write('mirror NUL'+'\n')
        for icoil in coilnum:
            a = data['xyzc'][data['n']==icoil]
            a[-1,-1,-1] = 0.0
            for ixyzc in a[:-2]:
                coilsfile.write(" ".join(map(str,ixyzc[0]))+'\n')
            coilsfile.write(" ".join(map(str,a[-1][0]))+'\t'+str(icoil)+'\t'+'Modular' +'\n')
        coilsfile.write('end'+'\n')
    print('Finish')

#------------------------------------------  6  ----------------------------------------------------
def plotBn(h5name, bntype='current'):
    '''
    This function is used for ploting the B normal distribution on the plasma surface calculated by
    FOCUS.
    INPUT : h5name(the hdf5 file name)
            bntype(target: plot tgtBn; current: plot curBn)
    OUTPUT: mlab figures
    '''
    with h5py.File(h5name, 'r') as h5file:
        x = h5file['xsurf'].value
        y = h5file['ysurf'].value
        z = h5file['zsurf'].value
        targetBn = h5file['tgtBn'].value
        currentBn = h5file['curBn'].value
    fig = mlab.figure(bgcolor=(1,1,1),fgcolor=(0,0,0),size=(600,600))
    if bntype == 'target':
        mesh = mlab.mesh(x,y,z,scalars=targetBn, colormap='RdBu')
    else:
        mesh = mlab.mesh(x,y,z,scalars=currentBn, colormap='RdBu')

#------------------------------------------  7  ----------------------------------------------------
def plot_coils(coil_data, plottype='filament', color=(0,0,1), width=2.0, recW=0.1, recH=0.1, \
                    opacity=1.0, WindSurf=None, EageOn=False, currents=False):
    '''
    This function plots out 3D coils in filename(coils file).
    It calls readcoil() to read coil and plot the data in mayave.
    INPUT :
            filename : coils file
            plottype : plot type (filament or real)
            color    : the single color tripet float; default blue;
            Ncolor   : number of colors used for coils (usually equals the number of coil categories)
    OUTPUT: 
            mlab figures (in current figure, otherwise in new figure)
    '''
    Ncoils = len(coil_data)
    cur_array = np.array([icoil.I for icoil in coil_data])
    maxI = np.max(abs(cur_array))

    colors = []
    for i in range(Ncoils):
        if currents:
            colors.append(cm.winter(int(128+coil_data[i].I/maxI*128))[0:3])
        else:
            colors.append(color) # identical colors for coils
    # plot coil currents
    if not currents:
        fig = plt.figure()
        ind = 1 + np.arange(Ncoils)
        for i in range(Ncoils):
            if coil_data[i].I >= 0.0:
                plt.bar(i+1, coil_data[i].I, color='r', align='center')
            else:
                plt.bar(i+1, coil_data[i].I, color='b', align='center')
        plt.xlabel('coil label',fontsize=16)
        plt.ylabel('currents [A]',fontsize=16)
        plt.xticks(ind, fontsize=16)
        plt.yticks(fontsize=16)
        plt.tight_layout()

    if plottype == 'filament' :
        for i in range(Ncoils):
            mlab.plot3d(coil_data[i].x, coil_data[i].y, coil_data[i].z, color = colors[i], line_width=width, opacity=opacity)
    elif plottype == 'real' :
        for i in range(Ncoils):
            xsurf, ysurf, zsurf = expand(coil_data[i].x, coil_data[i].y, coil_data[i].z, recW, recH, WindSurf)
            mlab.mesh(xsurf, ysurf, zsurf, color=colors[i], opacity=opacity)
            if EageOn :
                for ii in range(4):
                    mlab.plot3d(xsurf[ii,:], ysurf[ii,:], zsurf[ii,:], color=(0,0,0), line_width=width, opacity=opacity)

    return

#------------------------------------------  8  ----------------------------------------------------
def color_array( N ):
    '''
    This will return a list of N rgb float triplets from colorsysp.
    '''

    if N < 1 :
        raise ValueError("Please provide a positive integer!")
    return [colorsys.hsv_to_rgb((i+1.0)/3.0, 1.0, 1.0) for i in np.linspace(0.0, 1.0, N)]
    #return [(0.0, i, 1-i) for i in np.linspace(0.0, 1.0, N)]

#------------------------------------------  9  ----------------------------------------------------
def expand(x, y, z, b, h, WindSurf=None):
    '''
    This function expand single coil filament to a rectangle coil;
    x, y, z : array of the coil filament;
    b : width
    h : height
    WindSurf : winding surface data;
    '''
    n = np.size(x)
    t = np.linspace(0, 2*np.pi, n)
    dt = 2*np.pi/(n-1)

    xt = np.gradient(x)/dt
    yt = np.gradient(y)/dt
    zt = np.gradient(z)/dt

    xa = np.gradient(xt)/dt
    ya = np.gradient(yt)/dt
    za = np.gradient(zt)/dt

    aa = np.sqrt(xa*xa + ya*ya + za*za)

    # use surface normal if needed
    if WindSurf is not None:
        xn = np.zeros(n)
        yn = np.zeros(n)
        zn = np.zeros(n)
        for i in range(n):
            xn[i], yn[i], zn[i] = surfnorm(x[i], y[i], z[i], WindSurf)
    else:
        xn = xa / aa
        yn = ya / aa
        zn = za / aa
   
    xb = yt*zn - yn*zt
    yb = zt*xn - zn*xt
    zb = xt*yn - xn*yt

    x1 = x - b/2*xb + h/2*xn
    y1 = y - b/2*yb + h/2*yn
    z1 = z - b/2*zb + h/2*zn

    x2 = x + b/2*xb + h/2*xn
    y2 = y + b/2*yb + h/2*yn
    z2 = z + b/2*zb + h/2*zn

    x3 = x + b/2*xb - h/2*xn
    y3 = y + b/2*yb - h/2*yn
    z3 = z + b/2*zb - h/2*zn

    x4 = x - b/2*xb - h/2*xn
    y4 = y - b/2*yb - h/2*yn
    z4 = z - b/2*zb - h/2*zn

    xx = np.array([x1, x2, x3, x4, x1])
    yy = np.array([y1, y2, y3, y4, y1])
    zz = np.array([z1, z2, z3, z4, z1])

    return xx, yy, zz

#------------------------------------------  10  ----------------------------------------------------
#this can be consistent with plot_plasma-boundary
def plot_vmec_surface(wout, ns=-1, plottype='cross-section',zeta=0.0, zeta1=2*np.pi,
                         color=(1,0,0),style='-', marker=None, width=2.0, lbl='VMEC_surface',npol=128,ntor=128, prange='full'):
    '''
    wout : the vmec netcdf file;
    plot the ns-th flux surface;
    '''
    vmec = ncdata.open_dataset(wout)
    mf = vmec['mpol'].values
    nf = vmec['ntor'].values
    xm = vmec['xm'].values
    xn = vmec['xn'].values
    rmnc = vmec['rmnc'].values
    zmns = vmec['zmns'].values
    rbc = rmnc[ns,:]
    zbs = zmns[ns,:]

    if vmec['lasym__logical__'].values: # if no stellarator symmetry
        zmnc = vmec['zmnc'].values
        rmns = vmec['rmns'].values
        rbs = rmns[ns,:]
        zbc = zmnc[ns,:]
    else :
        rbs = np.zeros(np.shape(rbc))
        zbc = np.zeros(np.shape(rbc))
    
    if plottype=='cross-section' : #plot cross-section
        npoints = 361 #number of points
        theta = np.linspace(0,2*np.pi, npoints)
        r = np.zeros(npoints)
        z = np.zeros(npoints)
        for ipoint in range(npoints):
            tmpr = rbc*np.cos(xm*theta[ipoint]-xn*zeta) + rbs*np.sin(xm*theta[ipoint]-xn*zeta)
            r[ipoint] = np.sum(tmpr) #r value at ipont

            tmpz = zbs*np.sin(xm*theta[ipoint]-xn*zeta) + zbc*np.cos(xm*theta[ipoint]-xn*zeta)
            z[ipoint] = np.sum(tmpz) #z value at ipont
        if plt.get_fignums():
            fig = plt.gcf()
            ax = plt.gca()
        else :
            fig, ax = plt.subplots()
        if prange == 'full':
            ax.plot(r, z, color=color,linewidth=width,linestyle=style,label=lbl, marker=marker)
            return r, z
        elif prange == 'upper':
            ax.plot(r[0:npoints/2+1], z[0:npoints/2+1], color=color,linewidth=width,linestyle=style,label=lbl)
            return r[0:npoints/2+1], z[0:npoints/2+1]
        elif prange == 'below':
            ax.plot(r[npoints/2:npoints], z[npoints/2:npoints], color=color,linewidth=width,linestyle=style,label=lbl)
            return r[npoints/2:npoints], z[npoints/2:npoints]
        else:
            raise NameError("No such option!")
        plt.axis('equal')
    #mayavi 3D plot
    elif plottype == 'surface3d' :
        x=np.zeros((npol+1,ntor+1))
        y=np.zeros((npol+1,ntor+1))
        z=np.zeros((npol+1,ntor+1))

        for i in range(ntor+1):
            ator = zeta + (i+0.5)*(zeta1-zeta)/ntor #zeta
            for j in range(npol+1):
                apol = (j+0.5)*2*np.pi/npol #theta
                tmpr = rbc*np.cos(xm*apol-xn*ator) 
                tmpz = zbs*np.sin(xm*apol-xn*ator)

                x[j,i] = np.sum(tmpr) * np.cos(ator)
                y[j,i] = np.sum(tmpr) * np.sin(ator)
                z[j,i] = np.sum(tmpz)                
        #fig = mlab.figure(bgcolor=(1,1,1),fgcolor=(0,0,0),size=(600,600))
        mlab.mesh(x,y,z,color=color)
        return x, y, z
    else :
        raise NameError("No such option!")
        print "plottype = cross-section/surface3d"

#------------------------------------------  11  ----------------------------------------------------
def plot_poincare( path, pp, code='Glass', prange='full', dotsize=0.5, marker='o', color='blue'):
    '''
    This function is for plotting Oculus style Poincare plots data.
    INPUT:
         path  -> directory path;
         pp    -> poincare plot data file name;
         code  -> code name, Glass or Focus;
         prange-> plot range, full, upper or lower;
    plot poincare in current figure;
    '''

    num = 0 #reset numberig
    suffix = 'gl' if code == 'Glass' else 'fo'
    ppfile = path + '.' + pp + '.' + suffix + '.P.' + str(num).zfill(3) + '.dat'
    # get current figure or build new one;
    if plt.get_fignums():
        fig = plt.gcf()
        ax = plt.gca()
    else :
        fig, ax = plt.subplots()
    # scattering data;      
    while os.path.isfile(ppfile):
        r,z = read_ppfile(ppfile)

        if prange == 'full':
            ax.scatter(r,z,dotsize,marker=marker,color=color)
        elif prange == 'upper':
            ax.scatter(r[z>=0.0],z[z>=0.0],dotsize,marker=marker,color=color)
        elif prange == 'lower':
            ax.scatter(r[z<=0.0],z[z<=0.0],dotsize,marker=marker,color=color)

        num += 1
        ppfile = path + '.' + pp + '.' + suffix + '.P.' + str(num).zfill(3) + '.dat'
    print "Poincare plots finished in ", path

#------------------------------------------  12  ----------------------------------------------------

def hdf5coil(h5data, nn = -1, old=False):
    '''
    read FOCUS hdf5 output file and return the nn-th coil data
    '''
    if not isinstance(h5data, hdf5):
        print h5data, " is not a valid FOCUS hdf5 file."
        return
    ncoil = h5data.Ncoils[0]  #array to index
    assert ncoil>0
    nf = h5data.NFcoil[0]
    assert nf>0
    if old:
        nseg = h5data.NDcoil[0]
    else:
        nseg = h5data.Nseg[0]
    assert nseg>0
    coilfou = np.reshape(h5data.coilspace[:,nn], (ncoil,-1)) #all coil data at nn time; and reshape
    coildata = np.ndarray((ncoil,),dtype=np.object)

    for icoil in range(ncoil):
        
        if old: #old format hdf5
            tmpfou = np.reshape(coilfou[icoil, 4:], (nf, 6))
            xyzfou = np.zeros([3, 2*nf+1], dtype=np.float64)
            xyzfou[0, 0] = coilfou[icoil, 1] #xc0
            xyzfou[1, 0] = coilfou[icoil, 2] #yc0
            xyzfou[2, 0] = coilfou[icoil, 3] #yc0
            xyzfou[0, 1:nf+1] = tmpfou[:, 0] #xc(1:n)
            xyzfou[1, 1:nf+1] = tmpfou[:, 1] #yc(1:n)
            xyzfou[2, 1:nf+1] = tmpfou[:, 2] #zc(1:n)
            xyzfou[0, nf+1:2*nf+1] = tmpfou[:, 3] #xs(1:n)
            xyzfou[1, nf+1:2*nf+1] = tmpfou[:, 4] #ys(1:n)
            xyzfou[2, nf+1:2*nf+1] = tmpfou[:, 5] #zs(1:n)
        else:
            xyzfou = np.reshape(coilfou[icoil,1:], (3,-1))  #pop current and reshape in 3 rows;
 
        coildata[icoil] = coil()
        coildata[icoil].I = coilfou[icoil,0]  #coil current;
        coildata[icoil].group = icoil
        coildata[icoil].x.extend(fourier(xyzfou[0,:]).disc(nseg))
        coildata[icoil].y.extend(fourier(xyzfou[1,:]).disc(nseg))
        coildata[icoil].z.extend(fourier(xyzfou[2,:]).disc(nseg))
    print "Read {} coils.".format(ncoil)
    return coildata

#------------------------------------------  13  ----------------------------------------------------

def coilevolve(h5data, Nfp=None, delay=250, nout=-1, old=False, savepng=False, aniname='coil_evolution', fps=10):
    '''
    plot coil evolution movie
    '''
    if not isinstance(h5data, hdf5):
        print h5data, " is not a valid FOCUS hdf5 file."
        return

    Ncoils = h5data.Ncoils[0]  #array to index
    assert Ncoils>0
    nf = h5data.NFcoil[0]
    assert nf>0
    if old:
        nseg = h5data.NDcoil[0]
    else:
        nseg = h5data.Nseg[0]
    assert nseg>0
    if nout < 0:
        if old:
            nout = h5data.itau[0]
        else:
            nout = h5data.iout[0] 
    assert nout>1
    if Nfp is None:
        if old:
            Nfp = 1
        else:
            Nfp = h5data.Nfp[0]
    unicoil = Ncoils/Nfp

    xx = np.zeros([Ncoils,nseg], dtype=np.float64)
    yy = np.zeros([Ncoils,nseg], dtype=np.float64)
    zz = np.zeros([Ncoils,nseg], dtype=np.float64)
    c = color_array(unicoil)
    coils = []

    # first coils
    coilfou = np.reshape(h5data.coilspace[:,0], (Ncoils,-1))
    for icoil in range(unicoil):
        if old: #old format hdf5
            tmpfou = np.reshape(coilfou[icoil, 4:], (nf, 6))
            xyzfou = np.zeros([3, 2*nf+1], dtype=np.float64)
            xyzfou[0, 0] = coilfou[icoil, 1] #xc0
            xyzfou[1, 0] = coilfou[icoil, 2] #yc0
            xyzfou[2, 0] = coilfou[icoil, 3] #yc0
            xyzfou[0, 1:nf+1] = tmpfou[:, 0] #xc(1:n)
            xyzfou[1, 1:nf+1] = tmpfou[:, 1] #yc(1:n)
            xyzfou[2, 1:nf+1] = tmpfou[:, 2] #zc(1:n)
            xyzfou[0, nf+1:2*nf+1] = tmpfou[:, 3] #xs(1:n)
            xyzfou[1, nf+1:2*nf+1] = tmpfou[:, 4] #ys(1:n)
            xyzfou[2, nf+1:2*nf+1] = tmpfou[:, 5] #zs(1:n)
        else:
            xyzfou = np.reshape(coilfou[icoil,1:], (3,-1))  #pop current and reshape in 3 rows;

        xx[icoil,:] = fourier(xyzfou[0,:]).disc(nseg)
        yy[icoil,:] = fourier(xyzfou[1,:]).disc(nseg)
        zz[icoil,:] = fourier(xyzfou[2,:]).disc(nseg)
        l = mlab.plot3d(xx[icoil,:], yy[icoil,:], zz[icoil,:], np.ones_like(xx[icoil,:]), color=c[icoil%unicoil])
        coils.append(l)

    @mlab.animate(delay=delay)
    def anim():
        for iout in range(nout):
            coilfou = np.reshape(h5data.coilspace[:,iout], (Ncoils,-1)) #all coil data at iout time;
            for icoil in range(unicoil):
                if old: #old format hdf5
                    tmpfou = np.reshape(coilfou[icoil, 4:], (nf, 6))
                    xyzfou = np.zeros([3, 2*nf+1], dtype=np.float64)
                    xyzfou[0, 0] = coilfou[icoil, 1] #xc0
                    xyzfou[1, 0] = coilfou[icoil, 2] #yc0
                    xyzfou[2, 0] = coilfou[icoil, 3] #yc0
                    xyzfou[0, 1:nf+1] = tmpfou[:, 0] #xc(1:n)
                    xyzfou[1, 1:nf+1] = tmpfou[:, 1] #yc(1:n)
                    xyzfou[2, 1:nf+1] = tmpfou[:, 2] #zc(1:n)
                    xyzfou[0, nf+1:2*nf+1] = tmpfou[:, 3] #xs(1:n)
                    xyzfou[1, nf+1:2*nf+1] = tmpfou[:, 4] #ys(1:n)
                    xyzfou[2, nf+1:2*nf+1] = tmpfou[:, 5] #zs(1:n)
                else:
                    xyzfou = np.reshape(coilfou[icoil,1:], (3,-1))  #pop current and reshape in 3 rows;

                xx[icoil,:] = fourier(xyzfou[0,:]).disc(nseg)
                yy[icoil,:] = fourier(xyzfou[1,:]).disc(nseg)
                zz[icoil,:] = fourier(xyzfou[2,:]).disc(nseg)
                coils[icoil].mlab_source.set(x=xx[icoil,:], y=yy[icoil,:], z=zz[icoil,:])
            mlab.title('iter = '+ str(iout), size=0.5)
            #print "savepng = ", savepng, iout
            if savepng :
                print "hi", iout
                filename = aniname+'_'+str(iout).zfill(6)+'.png'
                mlab.savefig(filename=filename)
            yield
        #mlab.close(mlab.clf())

    anim()
    mlab.show()
    if savepng:
        cmd = 'convert -delay {} -loop 0 {} {}'.format(10.0/fps, aniname+'_*.png', aniname+'.gif')
        subprocess.call(cmd, shell=True)
        subprocess.call("rm -f "+aniname+'_*.png', shell=True)

    return

#------------------------------------------  14  ----------------------------------------------------

def chievolve(h5data, term='chi', width = 2.5, linestyle='-', color='b'):
    '''
    plot chi-square cost functions evolution curves
    '''
    # check data type
    if not isinstance(h5data, hdf5):
        print h5data, " is not a valid FOCUS hdf5 file."
        return

    # get fig and axis
    if plt.get_fignums():
        fig = plt.gcf()
        ax = plt.gca()
    else :
        fig, ax = plt.subplots(facecolor = "white", figsize=[8,6], dpi=125)
        
    # get data
    iteration = range(len(h5data.evolution[0,:]))
    if term == 'chi':
        target = h5data.evolution[1,:]
        label = r'$ \chi^2$'
    elif term == 'deriv':
        target = h5data.evolution[2,:]
        label = r'$|d \chi^2 / d {\bf X}|$'
    elif term == 'bnorm':
        target = h5data.evolution[3,:]
        label = r'$ f_B$'     
    elif term == 'bharm':
        target = h5data.evolution[4,:]
        label = r'$ f_H$'    
    elif term == 'tflux':
        target = h5data.evolution[5,:]
        label = r'$ f_{\Psi}$'   
    elif term == 'ttlen':
        target = h5data.evolution[6,:]
        label = r'$ f_L$' 
    else :
        print term, " is not a valid option."
        return
    
    # plotting
    ax.semilogy(iteration, target, linewidth=width, label=label, linestyle=linestyle, color=color)
    plt.xticks(fontsize=16)
    plt.yticks(fontsize=16)
    plt.xlabel('iteration',fontsize=24)
    plt.ylabel(label,fontsize=24)
    plt.legend(loc='upper right', frameon=False, prop={'size':24, 'weight':'bold'})

    return

#------------------------------------------  15  ----------------------------------------------------

def plot_hdf5_surface(h5data, plottype='surf', color=(1,0,0) ):
    '''
    plot plasma surface from the hdf5 data

    plottype:
            'surf'      : just plot the surface with pure color;
            'targetBn'  : plot the surface with target Bn distribution;
            'realizedBn': plot the surface with realized Bn distribution;
            'Bmod'      : plot the surface with |B| distribution;
    '''

    if not isinstance(h5data, hdf5):
        print h5data, " is not a valid FOCUS hdf5 file."
        return

    # data manipulation
    nt =  h5data.Nteta[0] #opposite notation for nt & nz!
    nz =  h5data.Nzeta[0]  
    xx = np.zeros([nt+1,nz+1], dtype=np.float64)
    yy = np.zeros([nt+1,nz+1], dtype=np.float64)
    zz = np.zeros([nt+1,nz+1], dtype=np.float64)
    Bn = np.zeros([nt+1,nz+1], dtype=np.float64)
    Bm = np.zeros([nt+1,nz+1], dtype=np.float64)

    xx[0:nt, 0:nz] = np.transpose(h5data.xsurf[0:nz, 0:nt])
    xx[  nt, 0:nz] = xx[0   , 0:nz]
    xx[0:nt,   nz] = xx[0:nt, 0   ]
    xx[  nt,   nz] = xx[0   , 0   ]

    yy[0:nt, 0:nz] = np.transpose(h5data.ysurf[0:nz, 0:nt])
    yy[  nt, 0:nz] = yy[0   , 0:nz]
    yy[0:nt,   nz] = yy[0:nt, 0   ]
    yy[  nt,   nz] = yy[0   , 0   ]

    zz[0:nt, 0:nz] = np.transpose(h5data.zsurf[0:nz, 0:nt])
    zz[  nt, 0:nz] = zz[0   , 0:nz]
    zz[0:nt,   nz] = zz[0:nt, 0   ]
    zz[  nt,   nz] = zz[0   , 0   ]

    #plot
    if plottype == 'surf':
        mlab.mesh(xx, yy, zz, color=color)
    elif plottype == 'targetBn':
        for i in range(nz+1):
            ator = (i+0.5)*2*np.pi/nz #zeta
            for j in range(nt+1):
                apol = (j+0.5)*2*np.pi/nt #theta
                tmpBn = h5data.target_Bmnc*np.cos(h5data.Bmnim*apol-h5data.Bmnin*ator) \
                     + h5data.target_Bmns*np.sin(h5data.Bmnim*apol-h5data.Bmnin*ator)

                Bn[j,i] = np.sum(tmpBn)
        mlab.mesh(xx, yy, zz, scalars=Bn, colormap='coolwarm')
        axes = mlab.colorbar( orientation='vertical', label_fmt='%.1e')
        axes.title_text_property.font_family = 'times'
        axes.title_text_property.font_size = 6
        axes.title_text_property.italic = False
        axes.label_text_property.font_family = 'times'
        axes.label_text_property.font_size = 100
        axes.label_text_property.italic = False
    elif plottype == 'realizedBn':
        Bn[0:nt, 0:nz] = np.transpose(h5data.Bn[0:nz, 0:nt])
        Bn[  nt, 0:nz] = Bn[0   , 0:nz]
        Bn[0:nt,   nz] = Bn[0:nt, 0   ]
        Bn[  nt,   nz] = Bn[0   , 0   ]
        mlab.mesh(xx, yy, zz, scalars=Bn, colormap='coolwarm')
        axes = mlab.colorbar(orientation='vertical', label_fmt='%.1e')
        axes.title_text_property.font_family = 'times'
        axes.title_text_property.font_size = 6
        axes.title_text_property.italic = False
        axes.label_text_property.font_family = 'times'
        axes.label_text_property.font_size = 100
        axes.label_text_property.italic = False
    elif plottype == 'Bmod':
        Bm[0:nt, 0:nz] = np.transpose(np.sqrt(h5data.Bx*h5data.Bx +
                                              h5data.By*h5data.By +
                                              h5data.Bz*h5data.Bz ))
        Bm[  nt, 0:nz] = Bm[0   , 0:nz]
        Bm[0:nt,   nz] = Bm[0:nt, 0   ]
        Bm[  nt,   nz] = Bm[0   , 0   ]
        mlab.mesh(xx, yy, zz, scalars=Bm, colormap='coolwarm')
        axes = mlab.colorbar(orientation='vertical', label_fmt='%.1e')
        axes.title_text_property.font_family = 'times'
        axes.title_text_property.font_size = 6
        axes.title_text_property.italic = False
        axes.label_text_property.font_family = 'times'
        axes.label_text_property.font_size = 100
        axes.label_text_property.italic = False
    else :
        raise NameError("No such option!")
        print "plottype = surf/targetBn/realizedBn/Bmod"
    return

#------------------------------------------  16  ----------------------------------------------------
    
def read_focus(filename):
    '''
    filename : the path for the focus coils file
    return an array of focus class;
    '''
    if not os.path.exists(filename) :
        raise IOError ("File not existed. Please check again!")

    with open(filename,'r') as focusfile: 

        focusfile.readline()
        linelist = focusfile.readline().split()
        Ncoils = int(linelist[0])  # get the number of coils;

        focus_array = np.ndarray((Ncoils,),dtype=np.object) # intialize empty array;

        for icoil in range(Ncoils): # read each coils;
            
            focusfile.readline()
            focusfile.readline()

            linelist = focusfile.readline().split()
            itype = int(linelist[0])
            coilname = linelist[1]

            focusfile.readline()
            linelist = focusfile.readline().split()
            Nseg =   int(linelist[0])
            I    = float(linelist[1])
            Ic   =   int(linelist[2])
            L    = float(linelist[3])
            Lc   =   int(linelist[4])
            Lo   = float(linelist[5])
  
            focusfile.readline()
            linelist = focusfile.readline().split()
            NFcoil = int(linelist[0])
          
            focus_array[icoil] = focus(itype, NFcoil) # initialize with focus class;
            focus_array[icoil].name = coilname
            focus_array[icoil].NS    = Nseg
            focus_array[icoil].I    = I
            focus_array[icoil].Ic   = Ic
            focus_array[icoil].L    = L
            focus_array[icoil].Lc   = Lc
            focus_array[icoil].Lo   = Lo

            focusfile.readline()
            linelist = focusfile.readline().split()
            focus_array[icoil].xc = map(float, linelist)
            linelist = focusfile.readline().split()
            focus_array[icoil].xs = map(float, linelist)
            linelist = focusfile.readline().split()
            focus_array[icoil].yc = map(float, linelist)
            linelist = focusfile.readline().split()
            focus_array[icoil].ys = map(float, linelist)
            linelist = focusfile.readline().split()
            focus_array[icoil].zc = map(float, linelist)
            linelist = focusfile.readline().split()
            focus_array[icoil].zs = map(float, linelist)

    print "Read {} focus format coils in {}.".format(Ncoils, filename)
    return(focus_array)

#------------------------------------------  17  ----------------------------------------------------
    
def write_coils(coildata, filename, Nfp=1):
    '''
    coildata : coil or focus type of numpy object arrays;
    filename : the path for the focus coils file;

    write a file with filename
    '''
    Ncoils = len(coildata)  # coils number;
    assert Ncoils > 0

    if isinstance(coildata[0], focus) : # focus class type;
        print "Writing {} focus format coils to {}".format(Ncoils, filename)
        with open(filename, 'w') as wfile :
            wfile.write(" # Total number of coils \n")
            wfile.write("{:6d}\n".format(Ncoils))
            for icoil in range(Ncoils):
                wfile.write("#-----------------{}---------------------------\n".format(icoil+1))
                wfile.write("#coil_type     coil_name \n")
                wfile.write("   {:3d}    {:10}\n".format(coildata[icoil].itype, coildata[icoil].name))
                wfile.write("{:^6} {:^23} {:^6} {:^23} {:^6} {:^23}\n"\
                    .format(" #Nseg", "current",  "Ifree", "Length", "Lfree", "target_length"))
                wfile.write("{:^6d} {:^23.15E} {:^6d} {:^23.15E} {:^6d} {:^23.15E}\n"\
                   .format(coildata[icoil].NS, coildata[icoil].I, coildata[icoil].Ic, \
                               coildata[icoil].L, coildata[icoil].Lc, coildata[icoil].Lo))
                if coildata[icoil].itype == 1:
                    wfile.write("#NFcoil\n")
                    wfile.write("{:^7d}\n".format(coildata[icoil].NF))
                    wfile.write("#Fourier harmonics for coils ( xc; xs; yc; ys; zc; zs) \n")
                    for xyzcs in [coildata[icoil].xc, coildata[icoil].xs, coildata[icoil].yc, \
                                      coildata[icoil].ys, coildata[icoil].zc, coildata[icoil].zs] :
                        for ixyzcs in xyzcs:
                            wfile.write("{:23.15E} ".format(ixyzcs))
                        wfile.write(" \n")
            wfile.write("end \n")
    elif isinstance(coildata[0], coil) : #coil class type;
        print "Writing {} coil format coils in {} periods to {}".format(Ncoils*Nfp, Nfp, filename)
        allcoil = map_coils(coildata, Nfp)  # map coils if necessary;
        with open(filename, 'w') as wfile :
            wfile.write("periods {:3d} \n".format(Nfp))
            wfile.write("begin filament \n")
            wfile.write("mirror NIL \n")
            for icoil in allcoil:
                Nseg = len(icoil.x) # number of segments;
                assert Nseg > 1
                for iseg in range(Nseg-1): # the last point match the first one;
                    wfile.write("{:23.15E} {:23.15E} {:23.15E} {:23.15E}\n".format(icoil.x[iseg], icoil.y[iseg], icoil.z[iseg], icoil.I))
                wfile.write("{:23.15E} {:23.15E} {:23.15E} {:23.15E} {:6d} {:10} \n".format(icoil.x[0], icoil.y[0], icoil.z[0], 0.0, icoil.group, icoil.name))
            wfile.write("end \n")
    else :
        raise TypeError("Invalid data!")
        print "Please use either focus or coil class type data."
    return

#------------------------------------------  18  ----------------------------------------------------
    
def map_coils(coildata, Nfp):
    '''
    coildata : coil or focus type of numpy object arrays;
    Nfp      : number of field periodicity

    return a numpy object array with all the coils;
    '''
    assert Nfp >= 1
    if Nfp == 1:
        return coildata
    else:
        Nuniq = len(coildata)
        Ncoils = Nuniq * Nfp
        allcoil = np.ndarray((Ncoils,),dtype=np.object) # intialize empty array;

        for ifp in range(Nfp):
            cosphi = np.cos(2.0*ifp*np.pi/Nfp)            
            sinphi = np.sin(2.0*ifp*np.pi/Nfp)
            # copy the coils data;
            for icoil in range(Nuniq):
                allcoil[icoil + ifp*Nuniq] = coil() #initialize empty class;
                allcoil[icoil + ifp*Nuniq].I     = coildata[icoil].I
                allcoil[icoil + ifp*Nuniq].group = coildata[icoil].group
                allcoil[icoil + ifp*Nuniq].name  = coildata[icoil].name
                allcoil[icoil + ifp*Nuniq].z.extend(coildata[icoil].z)

                allcoil[icoil + ifp*Nuniq].x.extend(  np.array(coildata[icoil].x) * cosphi \
                                                    - np.array(coildata[icoil].y) * sinphi )
                allcoil[icoil + ifp*Nuniq].y.extend(  np.array(coildata[icoil].x) * sinphi \
                                                    + np.array(coildata[icoil].y) * cosphi )                
        return allcoil

#------------------------------------------  19  ----------------------------------------------------

def coilperturb(x0, dx, delta, nf, Ncoils, nouts=100, delay=250, old = True,
                savepng=False, gifname='perturbation', fps=2):
    '''
    plot coil perturbation movie
    '''

    width = 2.5
    nseg = 128

    if old:
        nfp = 1
    else:
        nfp = h5data.Nfp[0]
    unicoil = Ncoils/nfp

    xx = np.zeros([Ncoils,nseg], dtype=np.float32)
    yy = np.zeros([Ncoils,nseg], dtype=np.float32)
    zz = np.zeros([Ncoils,nseg], dtype=np.float32)
    c = color_array(unicoil)
    coils = []

    #initial status;
    coilinit = np.reshape(x0, (Ncoils,-1))
    for icoil in range(unicoil):
        if old: #old format hdf5
            tmpfou = np.reshape(coilinit[icoil, 4:], (nf, 6))
            xyzfou = np.zeros([3, 2*nf+1], dtype=np.float32)
            xyzfou[0, 0] = coilinit[icoil, 1] #xc0
            xyzfou[1, 0] = coilinit[icoil, 2] #yc0
            xyzfou[2, 0] = coilinit[icoil, 3] #yc0
            xyzfou[0, 1:nf+1] = tmpfou[:, 0] #xc(1:n)
            xyzfou[1, 1:nf+1] = tmpfou[:, 1] #yc(1:n)
            xyzfou[2, 1:nf+1] = tmpfou[:, 2] #zc(1:n)
            xyzfou[0, nf+1:2*nf+1] = tmpfou[:, 3] #xs(1:n)
            xyzfou[1, nf+1:2*nf+1] = tmpfou[:, 4] #ys(1:n)
            xyzfou[2, nf+1:2*nf+1] = tmpfou[:, 5] #zs(1:n)
        else:
            xyzfou = np.reshape(coilinit[icoil,1:], (3,-1))  #pop current and reshape in 3 rows;

        mlab.plot3d(fourier(xyzfou[0,:]).disc(nseg), fourier(xyzfou[1,:]).disc(nseg),
                    fourier(xyzfou[2,:]).disc(nseg), np.ones_like(fourier(xyzfou[0,:]).disc(nseg)), 
                    line_width=width, color=(0.5, 0.5, 0.5))

    # first coils
    coilfou = np.reshape(x0-delta*dx, (Ncoils,-1))
    for icoil in range(unicoil):
        if old: #old format hdf5
            tmpfou = np.reshape(coilfou[icoil, 4:], (nf, 6))
            xyzfou = np.zeros([3, 2*nf+1], dtype=np.float32)
            xyzfou[0, 0] = coilfou[icoil, 1] #xc0
            xyzfou[1, 0] = coilfou[icoil, 2] #yc0
            xyzfou[2, 0] = coilfou[icoil, 3] #yc0
            xyzfou[0, 1:nf+1] = tmpfou[:, 0] #xc(1:n)
            xyzfou[1, 1:nf+1] = tmpfou[:, 1] #yc(1:n)
            xyzfou[2, 1:nf+1] = tmpfou[:, 2] #zc(1:n)
            xyzfou[0, nf+1:2*nf+1] = tmpfou[:, 3] #xs(1:n)
            xyzfou[1, nf+1:2*nf+1] = tmpfou[:, 4] #ys(1:n)
            xyzfou[2, nf+1:2*nf+1] = tmpfou[:, 5] #zs(1:n)
        else:
            xyzfou = np.reshape(coilfou[icoil,1:], (3,-1))  #pop current and reshape in 3 rows;

        xx[icoil,:] = fourier(xyzfou[0,:]).disc(nseg)
        yy[icoil,:] = fourier(xyzfou[1,:]).disc(nseg)
        zz[icoil,:] = fourier(xyzfou[2,:]).disc(nseg)
        l = mlab.plot3d(xx[icoil,:], yy[icoil,:], zz[icoil,:], np.ones_like(xx[icoil,:]), line_width=width, color=c[icoil])
        coils.append(l)

    @mlab.animate(delay=delay)
    def anim():
        for iout in range(nouts+1):
            coilfou = np.reshape(x0+(np.float(2*iout)/nouts-1)*delta*dx, (Ncoils,-1)) #all coil data at iout time;
            for icoil in range(unicoil):
                if old: #old format hdf5
                    tmpfou = np.reshape(coilfou[icoil, 4:], (nf, 6))
                    xyzfou = np.zeros([3, 2*nf+1], dtype=np.float32)
                    xyzfou[0, 0] = coilfou[icoil, 1] #xc0
                    xyzfou[1, 0] = coilfou[icoil, 2] #yc0
                    xyzfou[2, 0] = coilfou[icoil, 3] #yc0
                    xyzfou[0, 1:nf+1] = tmpfou[:, 0] #xc(1:n)
                    xyzfou[1, 1:nf+1] = tmpfou[:, 1] #yc(1:n)
                    xyzfou[2, 1:nf+1] = tmpfou[:, 2] #zc(1:n)
                    xyzfou[0, nf+1:2*nf+1] = tmpfou[:, 3] #xs(1:n)
                    xyzfou[1, nf+1:2*nf+1] = tmpfou[:, 4] #ys(1:n)
                    xyzfou[2, nf+1:2*nf+1] = tmpfou[:, 5] #zs(1:n)
                else:
                    xyzfou = np.reshape(coilfou[icoil,1:], (3,-1))  #pop current and reshape in 3 rows;

                xx[icoil,:] = fourier(xyzfou[0,:]).disc(nseg)
                yy[icoil,:] = fourier(xyzfou[1,:]).disc(nseg)
                zz[icoil,:] = fourier(xyzfou[2,:]).disc(nseg)
                coils[icoil].mlab_source.set(x=xx[icoil,:], y=yy[icoil,:], z=zz[icoil,:])
            mlab.title('delta = '+ str((np.float(2*iout)/nouts-1)*delta), size=0.4)
            if savepng :
                filename = gifname+'_'+str(iout).zfill(6)+'.png'
                mlab.savefig(filename=filename)
            yield
        mlab.close(mlab.clf())
    anim()
    mlab.show()

    tt = np.linspace(-delta, delta, nouts)
    I0 = x0[0::(6*nf+4)]
    dI = dx[0::(6*nf+4)]
    for icoil in range(unicoil):
        plt.plot(tt, I0[icoil]+dI[icoil]*tt, label='coil_'+str(icoil))
    
    plt.legend(loc=1)
    plt.show()
    

    #write gif
    if savepng:
        cmd = 'convert -delay {} -loop 0 {} {}'.format(10.0/fps, aniname+'_*.png', aniname+'.gif')
        subprocess.call(cmd, shell=True)
        subprocess.call("rm -f "+gifname+'_*.png', shell=True)

    return

#------------------------------------------  20  ----------------------------------------------------

def surfnorm(x, y, z, WindSurf):
    '''
    x, y, z  : xyz coordinates
    WindSurf : toroidal surface data 
    '''
    tol = 2.5E-2  # the tolerance

    # find theta, phi corresponding to xyz
    R = np.sqrt(x**2 + y**2)
    if   x >  0.0 and y >= 0.0 : # [0,pi/2)
        phi = np.arcsin(y/R)
    elif x <= 0.0 and y >  0.0 : # [pi/2, pi)
        phi = np.arccos(x/R)
    elif x <  0.0 and y <= 0.0 : # [pi, 3/2 pi)
        phi = np.arccos(-x/R) + np.pi
    elif x >= 0.0 and y <  0.0 : # [3/2 pi, 2pi)
        phi = np.arcsin(y/R) + 2*np.pi
    
    def f(theta, phi, R0, z0, WindSurf):
        return    ( np.sum( WindSurf['Zbc']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) + \
                            WindSurf['Zbs']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) ) - z0)**2 + \
                  ( np.sum( WindSurf['Rbc']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) + \
                            WindSurf['Rbs']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) ) - R0)**2

    
    res = optimize.minimize(f, 0.0, args=(phi, R, z, WindSurf), method='Powell')
    if res.success :
        theta = np.asscalar(res.x)
    else :
        print res.message

    R2 = np.sum( WindSurf['Rbc']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) + \
                 WindSurf['Rbs']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) )

    if abs(R2-R) > tol :
        theta = optimize.fminbound(f, 0, 2*np.pi, args=(phi, R, z, WindSurf), xtol=1e-20)
        
    R3 = np.sum( WindSurf['Rbc']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) + \
                 WindSurf['Rbs']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) )
    if abs(R3-R) > tol*10 :
        print "R, R2, R3 = ", R, R2, R3, " ; theta, phi = ", theta, phi
        print "x, y, z = ", x, y, z, "|z-z0| = ", f(theta, phi, R, z, WindSurf)
        raise ValueError("The curve might not on the surface.")
    
    # calculate nx, ny, nz
    Rt = np.sum(- WindSurf['m'] * WindSurf['Rbc']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) + \
                  WindSurf['m'] * WindSurf['Rbs']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) )
    Rp = np.sum(  WindSurf['n'] * WindSurf['Rbc']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) + \
                - WindSurf['n'] * WindSurf['Rbs']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) )

    zt = np.sum(- WindSurf['m'] * WindSurf['Zbc']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) + \
                  WindSurf['m'] * WindSurf['Zbs']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) )
    zp = np.sum(  WindSurf['n'] * WindSurf['Zbc']*np.sin(WindSurf['m']*theta-WindSurf['n']*phi) + \
                - WindSurf['n'] * WindSurf['Zbs']*np.cos(WindSurf['m']*theta-WindSurf['n']*phi) )

    xt = Rt * np.cos(phi)
    xp = Rp * np.cos(phi) - R * np.sin(phi)
    yt = Rt * np.sin(phi)
    yp = Rp * np.sin(phi) + R * np.cos(phi)

    nx = zt*yp - zp*yt
    ny = xt*zp - xp*zt
    nz = yt*xp - yp*xt

    nn = np.sqrt(nx**2 + ny**2 + nz**2)
    return  nx/nn,  ny/nn, nz/nn

#------------------------------------------  21  ----------------------------------------------------

def fourier2coil(x0, nf, ncoil, old=False, nseg=128):
    '''
    vector of free variables to coil data
    '''
    
    coildata = np.ndarray((ncoil,),dtype=np.object)
    
    coilfou = np.reshape(x0, (ncoil,-1))
    I0 = x0[0::(6*nf+4)]
    
    for icoil in range(ncoil):
        coildata[icoil] = coil()
        if old: #old format hdf5
            tmpfou = np.reshape(coilfou[icoil, 4:], (nf, 6))
            xyzfou = np.zeros([3, 2*nf+1], dtype=np.float32)
            xyzfou[0, 0] = coilfou[icoil, 1] #xc0
            xyzfou[1, 0] = coilfou[icoil, 2] #yc0
            xyzfou[2, 0] = coilfou[icoil, 3] #yc0
            xyzfou[0, 1:nf+1] = tmpfou[:, 0] #xc(1:n)
            xyzfou[1, 1:nf+1] = tmpfou[:, 1] #yc(1:n)
            xyzfou[2, 1:nf+1] = tmpfou[:, 2] #zc(1:n)
            xyzfou[0, nf+1:2*nf+1] = tmpfou[:, 3] #xs(1:n)
            xyzfou[1, nf+1:2*nf+1] = tmpfou[:, 4] #ys(1:n)
            xyzfou[2, nf+1:2*nf+1] = tmpfou[:, 5] #zs(1:n)
        else:
            xyzfou = np.reshape(coilfou[icoil,1:], (3,-1))  #pop current and reshape in 3 rows;

        coildata[icoil].x = fourier(xyzfou[0,:]).disc(nseg)
        coildata[icoil].y = fourier(xyzfou[1,:]).disc(nseg)
        coildata[icoil].z = fourier(xyzfou[2,:]).disc(nseg)
        coildata[icoil].I = I0[icoil]
    return coildata

#------------------------------------------  22  ----------------------------------------------------
def vmec2focus(vmec_file, focus_file='plasma.boundary', bnorm_file = None, curpol = 1.0, old=True):
    '''
    vmec_file : VMEC  input/output file, input* / wout*;
    focus_file: FOCUS input file input*;
    bnorm_file: BNORM output file, bnorm*; Bn = sin(mu+nv), but in FOUCS Bn=cos(mu-nv) + sin(mu-nv)
    curpol    : poloidal current, read from VMEC output or by hand;
    old       : old version or new version FOCUS (they have different sign);

    // Compute net poloidal current required to produce vacuum toroidal field.
    // Note: The vacuum toroidal field produced by coils goes like 1/R,
    //  so R*B0 is constant. If RB0 is in Tesla-meters, then the required
    // current in amps to produce it is 2*pi*R*B0/mu_0, where mu_0 = 4*pi*1e-7,
    // or 5e+6 * RB0. (VMEC values absorb the mu_0 factor and are normalized
    //  to unit current/field period, so curpol_vmec = 2*pi*R*B0/nfper, i.e.,
    //  curpol_vmec = mu0 * reqpolcur_A / nfper = mu0 * 5e+6 * RB0 / nfper).

    '''
    # read vmec data
    # rbc(n,m)   {n=-ntor, +ntor (for m=0, only half)}  {m=0, +mpol-1}  
    if 'wout' in vmec_file: # netcdf format VMEC output
        wout = ncdata.open_dataset(vmec_file)
        mpol = int(wout['mpol'].values)
        ntor = int(wout['ntor'].values)
        rmnc = wout['rmnc'].values
        zmns = wout['zmns'].values
        rbc = rmnc[-1,:]
        zbs = zmns[-1,:]
        Nfp = int(wout['nfp'].values)
        #curpol = 5.0e6 * wout['rbtor0'].values / Nfp * (4*np.pi*1.0e-7) 
        curpol = 2.0*np.pi / Nfp * wout['rbtor'].values  # not rbtor0, it's rbtor
        print "Total poloidal current needed is ", 5.0*wout['rbtor'].values, " MA."
    elif 'input' in vmec_file: # input namelist of VMEC
        indata = f90nml.read(vmec_file)['indata']
        mpol = int(indata['mpol'])
        ntor = int(indata['ntor'])
        Nfp  = int(indata['nfp' ])
        rbc_ori  = np.ravel(np.array(indata['rbc'], dtype=np.float)) # one row
        zbs_ori  = np.ravel(np.array(indata['zbs'], dtype=np.float)) # one row
        rbc = [ibc if not np.isnan(ibc) else 0.0 for ibc in rbc_ori] # replace nan symbol with 0.0
        zbs = [ibs if not np.isnan(ibs) else 0.0 for ibs in zbs_ori]
    else:
        print "Please check your first argument. It should be wout* or input*."
    
    def vmecMN(mpol, ntor):
    # manipulate VMEC index
        mn = (2*ntor+1)*mpol - ntor # total number of Fourier harmonics
        xm = np.zeros((mn,), dtype=int)
        xn = np.zeros((mn,), dtype=int)
        imn = 0 
        for ii in range(mpol):
            for jj in range(-ntor, ntor+1):
                if ii==0 and jj<0 :
                    continue
                xm[imn] = ii
                xn[imn] = jj
                imn += 1
        return xm, xn
    
    # create VMEC index
    xm, xn = vmecMN(mpol, ntor)
    mn = (2*ntor+1)*mpol - ntor # total number of Fourier harmonics
    
    # BNORM output
    if bnorm_file is None : # no bnorm
        Nbnf = 0
    else :  # read BNORM file
        bm = []
        bn = []
        bns = []
        #bnc = []
        with open(bnorm_file, 'r') as bfile:
            for line in bfile:
                tmp = line.split() # BNORM format: m n Bn_sin
                bm.append(int(tmp[0]))
                bn.append(int(tmp[1]))                
                bns.append(float(tmp[2]))
        Nbnf = len(bm)
        bnc = np.zeros(Nbnf)
        bns = np.array(bns)*curpol
        print "Read ", Nbnf, " harmonics in BNORM file. M =", max(bm), ", N =", max(bn)
    
    # write FOCUS input
    with open(focus_file, 'w') as fofile:
        fofile.write('# bmn   bNfp   nbf '+'\n')
        fofile.write("{:d} \t {:d} \t {:d} \n".format(mn, Nfp, Nbnf))
        fofile.write('#plasma boundary'+'\n')
        fofile.write('# n m Rbc Rbs Zbc Zbs'+'\n')
        for imn in range(mn):
            fofile.write("{:4d}  {:4d} \t {:23.15E}  {:23.15E}  {:23.15E}  {:23.15E} \n".format(xn[imn], xm[imn], rbc[imn], 0.0, 0.0, zbs[imn]))
        fofile.write("#Bn harmonics curpol= {:23.15E} \n".format(curpol))
        fofile.write('# n m bnc bns'+'\n')
        if old :
            for imn in range(Nbnf):
                fofile.write("{:d} \t {:d} \t {:23.15E} \t {:23.15E} \n".format(-bn[imn], bm[imn], 0.0, bns[imn])) 
                # negative n, because FOCUS and BNORM are taking different rep.
        else :
            for imn in range(Nbnf):
                fofile.write("{:d} \t {:d} \t {:23.15E} \t {:23.15E} \n".format(-bn[imn], bm[imn], 0.0, -bns[imn])) 
                # negative sign for coef, since New FOCUS is addinng the Bn.
                # negative n, because FOCUS and BNORM are taking different rep.           
    print "Finished write FOCUS input file at ", focus_file
    return

#------------------------------------------  23  ----------------------------------------------------
def plot_fieldlines(filename, plottype='basic', cutplane=0, color='k', dotsize=0.1):
    '''
    plot the hdf5 file from FIELDLINES.
    filename: the filename of hdf5 output;
    plottype: plot type, 
              basic: Poincare plot at one plane; 
              sparse: less dense plot;
    cutplane: the specific plane for Poincare plot;
    color: scatter color;
    dotsize: scatter dot size;
    '''
    data = hdf5(filename)
    line_dex = range(cutplane, data.nsteps, data.npoinc) # data index
    if plottype == 'basic':
        lines = range(data.nlines)
    elif plottype == 'sparse':
        lines = range(0, data.nlines, 2)
    else:
        print "unsupported plottype!"
        return
    for i in lines:
        plt.scatter(data.R_lines[line_dex, i], data.Z_lines[line_dex, i], dotsize, color=color)
    plt.axis('equal')
    plt.xlabel('R [m]',fontsize=20)
    plt.ylabel('Z [m]',fontsize=20)
    plt.xticks(fontsize=16)
    plt.yticks(fontsize=16)
    plt.tight_layout()
    return   

#------------------------------------------  24  ----------------------------------------------------
def compare_dataset(data1, data2, tol=1E-8):
    '''
    compare the variables in two datasets, data1 and data2
    '''
    names = data1.keys()
    for var in names:
        # this is suitable for netcdf read by scipy.io
        dif = data1[var][()] - data2[var][()]
        if np.max(abs(dif)) / np.max(abs(data1[var][()])) > tol :
            print 'Found different term :', var
                                    

#------------------------------------------  25  ----------------------------------------------------
def mgrid_location(mgrid_file, position, extcur=None, xyz=True):
    '''
    return the magnetic field at a position in a mgrid file
    mgrid_file: file name in netcdf format
    position(0:2): coordinates of the evaluation point
    extcur(0:n-1): over-written the raw values of the currents
    xyz: using cartesian or cylinder coordinates
    '''
    mgrid = ncdata.open_dataset(mgrid_file)
    nextcur = mgrid['nextcur'].values # No. of current groups
    if extcur is None:
        extcur = mgrid['raw_coil_cur'].values
    assert len(extcur) == nextcur
    nr = mgrid['ir'].values  # R
    nz = mgrid['jz'].values  # Z
    nphi = mgrid['kp'].values  # Phi
    
    rmin = mgrid['rmin'].values
    rmax = mgrid['rmax'].values
    zmin = mgrid['zmin'].values
    zmax = mgrid['zmax'].values
    nfp = mgrid['nfp'].values

    '''
    i in [0, N-1]
    r = (rmax-rmin)*i/(nr-1)
    z = (zmax-zmin)*i/(nz-1)
    phi = (2Pi/nfp)*i/nphi
    '''
    
    if xyz :
        # get R, Phi, Z
        x = position[0]
        y = position[1]
        R = np.sqrt(position[0]**2 + position[1]**2)
        if   x >  0.0 and y >= 0.0 : # [0,pi/2)
            phi = np.arcsin(y/R)
        elif x <= 0.0 and y >  0.0 : # [pi/2, pi)
            phi = np.arccos(x/R)
        elif x <  0.0 and y <= 0.0 : # [pi, 3/2 pi)
            phi = np.arccos(-x/R) + np.pi
        elif x >= 0.0 and y <  0.0 : # [3/2 pi, 2pi)
            phi = np.arcsin(y/R) + 2*np.pi
        Phi = np.mod(phi, 2*np.pi/nfp)
        Z = position[2]
    else :
        R = position[0]
        Phi = np.mod(position[1], 2*np.pi/nfp)
        Z = position[2]
        
    # get index
    ir = np.int( np.rint( (R-rmin)/(rmax-rmin)*(nr-1) ) )
    ip = np.int( np.rint( Phi/(2*np.pi)*nfp*nphi ) )
    iz = np.int( np.rint( (Z-zmin)/(zmax-zmin)*(nz-1) ) )
    
    # print ir, ip, iz

    new_R = rmin + ir*(rmax-rmin)/(nr-1)
    new_phi = ip*2*np.pi/nfp/nphi
    new_Z = zmin + iz*(zmax-zmin)/(nz-1)

    print 'Closest point in (R, phi, Z): ', new_R, new_phi, new_Z
    
    # get magnetic field
    for ic in range(nextcur):
        if ic == 0:
            br = mgrid['br_001'].values * extcur[ic]
            bp = mgrid['bp_001'].values * extcur[ic]
            bz = mgrid['bz_001'].values * extcur[ic]
        else :
            br += mgrid['br_'+str(ic+1).zfill(3)].values * extcur[ic]
            bp += mgrid['bp_'+str(ic+1).zfill(3)].values * extcur[ic]
            bz += mgrid['bz_'+str(ic+1).zfill(3)].values * extcur[ic]
    
    # return magnetic field
    if xyz:
        B1 = br[ip, iz, ir] * np.cos(new_phi) - bp[ip, iz, ir] * np.sin(new_phi) # Bx
        B2 = br[ip, iz, ir] * np.sin(new_phi) + bp[ip, iz, ir] * np.cos(new_phi) # By
        B3 = bz[ip, iz, ir] # Bz
        print 'returned B field in cartesian.'
    else:
        B1 = br[ip, iz, ir] # Br
        B2 = bp[ip, iz, ir] # Bp
        B3 = bz[ip, iz, ir] # Bz
        print 'returned B field in cylinder.'
    
    return np.array([B1, B2, B3])


#------------------------------------------  26  ----------------------------------------------------
def compare_bn(focus_file, plottype='all', old=True, cmap='coolwarm'):
    '''
    Plot the target/realized Bn distribution on the theta-zeta plane.
    '''
    h5file = hdf5(focus_file)
    fig = plt.figure(figsize=[4,6])
    #fig, axes = plt.subplots(nrows=2, ncols=1)
    ax1 = plt.subplot(311)
    ax2 = plt.subplot(312, sharex=ax1)
    ax3 = plt.subplot(313, sharex=ax1)
    vm = np.min([h5file.tgtBn, h5file.curBn])
    vn = np.max([h5file.tgtBn, h5file.curBn])
    im1 = ax1.imshow(np.transpose(h5file.tgtBn), vmin=vm, vmax=vn, cmap=cmap)
    im2 = ax2.imshow(np.transpose(h5file.curBn), vmin=vm, vmax=vn, cmap=cmap)
    im3 = ax3.imshow(np.transpose(h5file.curBn-h5file.tgtBn), vmin=vm, vmax=vn, cmap=cmap)
    ax1.set_title('target Bnormal')
    ax2.set_title('realized Bnormal')
    ax3.set_title('difference')
    #ax1.set_xlabel(r'$\phi$')
    plt.setp(ax1.get_xticklabels(), visible=False)
    plt.setp(ax2.get_xticklabels(), visible=False)
    ax3.set_xlabel(r'$\phi$', fontsize=14)
    ax1.set_ylabel(r'$\theta$', fontsize=14)
    ax2.set_ylabel(r'$\theta$', fontsize=14)
    ax3.set_ylabel(r'$\theta$', fontsize=14)
    
    nz, nt = np.shape(h5file.tgtBn)
    #print nt, nz
    plt.setp(ax3, xticks=[0, nz/4, nz/2, 3*nz/4, nz], xticklabels=[r'0', r'$\pi$/2',r'$\pi$', r'3$\pi$/2', r'$2\pi$'] )
    plt.setp(ax1, yticks=[0, nt/4, nt/2, 3*nt/4, nt], yticklabels=[r'0', r'$\pi$/2',r'$\pi$', r'3$\pi$/2', r'$2\pi$'] )
    plt.setp(ax2, yticks=[0, nt/4, nt/2, 3*nt/4, nt], yticklabels=[r'0', r'$\pi$/2',r'$\pi$', r'3$\pi$/2', r'$2\pi$'] )
    plt.setp(ax3, yticks=[0, nt/4, nt/2, 3*nt/4, nt], yticklabels=[r'0', r'$\pi$/2',r'$\pi$', r'3$\pi$/2', r'$2\pi$'] )
    fig.subplots_adjust(right=0.80)
    cbar_ax = fig.add_axes([0.82, 0.10, 0.04, 0.8])
    fig.colorbar(im2, cax=cbar_ax)

    return

#------------------------------------------  27  ----------------------------------------------------
def plot_winding_surface(filename,plottype='cross-section',zeta=0.0, zeta1=2*np.pi, colormap='coolwarm',
                         color=(1,0,0),style='-',width=2.0,lbl='Target boundary',npol=128,ntor=128):
    '''
    plot the winding surface;
    plottype:
            cross-section -> 2D plot at zeta plane
            surface       -> 3D surface using matplotlib
            surface3d     -> 3D surface using mayavi
    '''
    with open(filename, 'r') as f:
        line = ''
        while "np     iota_edge       phip_edge       curpol" not in line:
            line = f.readline()
        line = f.readline()
        nfp = int(line.split()[0])
        print "nfp:",nfp

        line = ''
        while "------ Current Surface:" not in line:
            line = f.readline()
        line = f.readline()
        line = f.readline()
        print "Number of Fourier modes in coil surface from nescin file: ",line
        num = int(line)
        plas = np.zeros(num, dtype=[('m',np.float64), ('n', np.float64), #m,n saving as double
                                         ('Rbc', np.float64), ('Zbs', np.float64),
                                         ('Rbs', np.float64), ('Zbc', np.float64) ])
        line = f.readline() #skip one line
        line = f.readline() #skip one line
        for i in range(num):
            line = f.readline()
            plas[i] = tuple([float(j) for j in line.split()])
        plas['n'] *= nfp
    #print np.max(plas['Rbc']), np.max(plas['Rbs']), np.max(plas['Zbc']), np.max(plas['Zbs'])
    # ploting
    maxR, minR, maxZ, minZ = 0.0, 999.0, 0.0, 999.0
    if plottype=='cross-section' : #plot cross-section
        npoints = 360 #number of points
        theta = np.linspace(0,2* np.pi, npoints)
        r = np.zeros(npoints)
        z = np.zeros(npoints)
        for ipoint in range(npoints):
            tmpr = plas['Rbc']*np.cos(plas['m']*theta[ipoint]+plas['n']*zeta) + \
                   plas['Rbs']*np.sin(plas['m']*theta[ipoint]+plas['n']*zeta)
            r[ipoint] = np.sum(tmpr) #r value at ipont
            maxR = max(np.sum(tmpr), maxR)
            minR = min(np.sum(tmpr), minR)

            tmpz = plas['Zbc']*np.cos(plas['m']*theta[ipoint]+plas['n']*zeta) + \
                   plas['Zbs']*np.sin(plas['m']*theta[ipoint]+plas['n']*zeta)
            z[ipoint] = np.sum(tmpz) #z value at ipont
            maxZ = max(np.sum(tmpz), maxZ)
            minZ = min(np.sum(tmpz), minZ)
        if plt.get_fignums():
            fig = plt.gcf()
            ax = plt.gca()
        else :
            fig, ax = plt.subplots()
        ax.plot(r, z, color=color,linewidth=width,linestyle=style,label=lbl)
        plt.axis('equal')
        plt.xlabel('R [m]',fontsize=20)
        plt.ylabel('Z [m]',fontsize=20)
        plt.xticks(fontsize=16)
        plt.yticks(fontsize=16)
        plt.tight_layout()
        return maxR, minR, maxZ, minZ
    elif plottype == 'surface' : #plot surface
        if plt.get_fignums():
            fig = plt.gcf()
        else :
            fig = plt.figure()
        ax = fig.gca(projection='3d')
        x=np.zeros((npol+1,ntor+1))
        y=np.zeros((npol+1,ntor+1))
        z=np.zeros((npol+1,ntor+1))
        for i in range(ntor+1):
            ator = zeta + i*(zeta1-zeta)/ntor #zeta
            for j in range(npol+1):
                apol = j*2*np.pi/npol #theta
                tmpr = plas['Rbc']*np.cos(plas['m']*apol+plas['n']*ator) + \
                       plas['Rbs']*np.sin(plas['m']*apol+plas['n']*ator)
                tmpz = plas['Zbc']*np.cos(plas['m']*apol+plas['n']*ator) + \
                       plas['Zbs']*np.sin(plas['m']*apol+plas['n']*ator)
                maxR = max(np.sum(tmpr), maxR)
                minR = min(np.sum(tmpr), minR)
                maxZ = max(np.sum(tmpz), maxZ)
                minZ = min(np.sum(tmpz), minZ)
                x[j,i] = np.sum(tmpr) * np.cos(ator)
                y[j,i] = np.sum(tmpr) * np.sin(ator)
                z[j,i] = np.sum(tmpz)
        ax.plot_surface(x,y,z,color='white')
        #p1 = [x[npol/2  ,ntor/2  ], y[npol/2  ,ntor/2  ], z[npol/2  ,ntor/2  ]]
        #p2 = [x[npol/2+1,ntor/2  ], y[npol/2+1,ntor/2  ], z[npol/2+1,ntor/2  ]]
        #p3 = [x[npol/2  ,ntor/2+1], y[npol/2  ,ntor/2+1], z[npol/2  ,ntor/2+1]]
        #p4 = [x[npol/2+1,ntor/2+1], y[npol/2+1,ntor/2+1], z[npol/2+1,ntor/2+1]]
        return maxR, minR, maxZ, minZ
    elif plottype == 'surface3d' :
        x=np.zeros((npol+1,ntor+1))
        y=np.zeros((npol+1,ntor+1))
        z=np.zeros((npol+1,ntor+1))

        for i in range(ntor+1):
            ator = zeta + (i+0.5)*(zeta1-zeta)/ntor #zeta
            for j in range(npol+1):
                apol = (j+0.5)*2*np.pi/npol #theta
                tmpr = plas['Rbc']*np.cos(plas['m']*apol+plas['n']*ator) + \
                       plas['Rbs']*np.sin(plas['m']*apol+plas['n']*ator)
                tmpz = plas['Zbc']*np.cos(plas['m']*apol+plas['n']*ator) + \
                       plas['Zbs']*np.sin(plas['m']*apol+plas['n']*ator)
                maxR = max(np.sum(tmpr), maxR)
                minR = min(np.sum(tmpr), minR)
                maxZ = max(np.sum(tmpz), maxZ)
                minZ = min(np.sum(tmpz), minZ)
                x[j,i] = np.sum(tmpr) * np.cos(ator)
                y[j,i] = np.sum(tmpr) * np.sin(ator)
                z[j,i] = np.sum(tmpz)                
        #fig = mlab.figure(bgcolor=(1,1,1),fgcolor=(0,0,0),size=(600,600))
        surf = mlab.mesh(x,y,z,color=color, representation = 'surface')
        # Change the visualization parameters.
        #surf.actor.property.interpolation = 'phong'
        #surf.actor.property.specular = 01.0
        #surf.actor.property.specular_power = 100
        #surf.scene.light_manager.light_mode = "vtk"
        return x, y, z
    else :
        raise NameError("No such option!")
        print "plottype = cross-section/surface/surface3d"


#------------------------------------------  28  ----------------------------------------------------
def write_winding_coils(winding_surface, theta, zeta, coil_name='coils.winding_surface', currents=None):
    '''
    write down coils on a winding surface
    winding_surface: the filename of winding surface in nescin format;
    theta          : theta points in 2D plane, size = (Ncoils, Npoints);
     zeta          :  zeta points in 2D plane, size = (Ncoils, Npoints);
    coil_name      : the filename of output coils file;
    currents       : current in each coil, size=(Ncoils), if None, currents = 1E3;

    return : coil class for visualization
    '''
    tmp  = np.shape(theta)
    tmp2 = np.shape( zeta)
    assert tmp == tmp2
    
    if len(tmp) == 1 : # one coil
        Ncoils = 1
        Npoints = tmp[0]
    elif len(tmp) ==2 : # several coils
        Ncoils = tmp[0]
        Npoints = tmp[1]
    else :
        raise ValueError("theta should be in 1/2 dimension with (Ncoils,Npoints).")
    
    if currents is None:
        currents = np.zeros(Ncoils)
        currents = 1E3
    else:
        assert len(currents) == Ncoils

    # read winding surface
    with open(winding_surface, 'r') as f:
        line = ''
        while "np     iota_edge       phip_edge       curpol" not in line:
            line = f.readline()
        line = f.readline()
        nfp = int(line.split()[0])
        #print "nfp:",nfp

        line = ''
        while "------ Current Surface:" not in line:
            line = f.readline()
        line = f.readline()
        line = f.readline()
        #print "Number of Fourier modes in coil surface from nescin file: ",line
        num = int(line)
        plas = np.zeros(num, dtype=[('m',np.float64), ('n', np.float64), #m,n saving as double
                                         ('Rbc', np.float64), ('Zbs', np.float64),
                                         ('Rbs', np.float64), ('Zbc', np.float64) ])
        line = f.readline() #skip one line
        line = f.readline() #skip one line
        for i in range(num):
            line = f.readline()
            plas[i] = tuple([float(j) for j in line.split()])
        plas['n'] *= nfp    
    
    # coil data in real space
    coildata = np.ndarray((Ncoils,),dtype=np.object)
    for icoil in range(Ncoils):
        coildata[icoil] = coil()
        coildata[icoil].I = currents[icoil]
        coildata[icoil].x = np.zeros(Npoints)
        coildata[icoil].y = np.zeros(Npoints)
        coildata[icoil].z = np.zeros(Npoints)
        coildata[icoil].group = icoil+1
        coildata[icoil].name = 'WS_coil'
        for ipoint in range(Npoints) :
            tmpr = plas['Rbc']*np.cos(plas['m']*theta[icoil, ipoint]+plas['n']*zeta[icoil, ipoint]) + \
                   plas['Rbs']*np.sin(plas['m']*theta[icoil, ipoint]+plas['n']*zeta[icoil, ipoint])
            tmpz = plas['Zbc']*np.cos(plas['m']*theta[icoil, ipoint]+plas['n']*zeta[icoil, ipoint]) + \
                   plas['Zbs']*np.sin(plas['m']*theta[icoil, ipoint]+plas['n']*zeta[icoil, ipoint])
            r = np.sum(tmpr) # r value at ipont
            z = np.sum(tmpz) # r value at ipont
            coildata[icoil].x[ipoint] = r*np.cos(zeta[icoil, ipoint])
            coildata[icoil].y[ipoint] = r*np.sin(zeta[icoil, ipoint])
            coildata[icoil].z[ipoint] = z
    # write coils
    write_coils(coildata, coil_name, nfp)
    print "Write coils to ", coil_name
    return coildata
    
'''
    
#------------------------------------------  23  ----------------------------------------------------
def scan_para(input
'''
