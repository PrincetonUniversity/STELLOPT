      SUBROUTINE load_physics_codes(executable, input, command_line,
     1    output, extension, iunit, iflag)
      USE stel_kinds
      USE read_boozer_mod
      USE safe_open_mod
      USE system_mod
      USE mpi_params                                                     !MPI
      USE optim, ONLY: ns_booz_max
      IMPLICIT NONE
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      INTEGER :: iunit, iflag
      CHARACTER(LEN=*), INTENT(in) :: executable, input, output, 
     1    extension, command_line
C-----------------------------------------------
C   L o c a l   P a r a m e t e r s
C-----------------------------------------------
      INTEGER, PARAMETER :: num_exec = 13
      CHARACTER(LEN=12), DIMENSION(num_exec), PARAMETER :: exec_string =
     1 ( / 'xvmec2000   ', 'xbootsj     ', 'xbooz_xform ',
     2     'xj_invariant', 'xcobravmec  ', 'xbnorm      ',
     3     'xnescoil    ', 'xdkes       ', 'xtprp       ',
     4     'xneo        ', 'xvacopt     ', 'xanimec     ',
     5     'xdiagnov3   '/ )
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      INTEGER :: istat=0, index_exec, iexec, i, ierror
      INTEGER :: iprint
      CHARACTER(LEN=LEN_TRIM(INPUT) + LEN_TRIM(EXTENSION)
     1   + len_trim(COMMAND_LINE) + 1) :: input_ext
      CHARACTER(LEN=LEN_TRIM(OUTPUT) + LEN_TRIM(EXTENSION) + 1) ::
     1    output_ext
C-----------------------------------------------
!     THIS ROUTINE EXECUTES A PHYSICS CODE (CALLED executable) USING A
!     SYSTEM CALL. IT HANDLES POSSIBLE ERRORS DUE TO FILE NON-EXISTENCE,
!     OUT OF PROCESSORS, ETC. IT READS/OPENS (FOR IUNIT) APPROPRIATE FILES
!     PRODUCED BY THE SUCESSFUL EXECUTION OF THE PHYSICS CODE.
!
!     INPUT VARIABLES
!
!     EXECUTABLE:   physics code to execute using system call
!     INPUT:        input file name, without extension
!     COMMAND_LINE: screen, noscreen, lreset
!     OUTPUT:       data output file (without extension) resulting
!                   from execution of the executable


      input_ext = TRIM(input)
      IF (input(1:1) .ne. ' ')
     1    input_ext = TRIM(input) // '.' // TRIM(extension)
      output_ext = TRIM(output) // '.' // TRIM(extension)
      iflag = 0
!
!     SPECIAL CASES
!
      iexec = -1
      DO i = 1, num_exec
         index_exec = INDEX(executable, TRIM(exec_string(i)))
         IF (index_exec .gt. 0) THEN
            iexec = i
            EXIT
         END IF
      END DO

      IF (iexec .eq. -1) THEN
         PRINT *,'Executable not found: ', TRIM(executable)
         iflag = -17
         RETURN
      END IF

      input_ext = TRIM(input_ext) // TRIM(command_line)

      iprint = -1
 10   CALL system(TRIM(executable) // ' ' // TRIM(input_ext), ierror)

!
!     Parallel processing control - wait for process to execute in system CALL
!
      IF (ierror.lt.127 .and. ierror.ne.0) THEN
         iprint = iprint+1
         IF (iprint .eq. 0) THEN
            PRINT *,' Processor ', myid,': System error = ', ierror,
     1        ' EXECUTING  ',
     2        TRIM(executable),' ', TRIM(input_ext)
         END IF
         IF (iprint .le. 10) THEN
            GOTO 10
         ELSE
            iflag = -2
            RETURN
         END IF
      END IF

!
!     FOR XVMEC2000 (OR XANIMEC), MUST READ IN DATA FROM WOUT FILE GENERATED BY SUCCESSFUL RUN
!     FOR XBOOZ_XFORM, READ IN DATA FROM BOOZMN FILE
!     FOR ALL OTHER EXECUTABLES, OPEN OUTPUT FILE PRODUCED BY EXECUTABLE
!
      IF ((iexec == 1) .or. (iexec == 12)) THEN
         iexec = 1  ! This is forces read_wout_opt to read a VMEC file
         CALL read_wout_opt(iexec, extension, ierror, istat)
         IF (ierror .ne. 0) THEN
            iflag = -8
         ELSE IF (istat .ne. 0) THEN
            iflag = -1
         END IF
         IF (iflag .ne. 0) RETURN
      ELSE IF (iexec == 3) THEN
         IF (ns_booz_max .ge. 1) THEN
            CALL read_boozer_file (extension, ierror, istat)
            IF (ierror .ne. 0) THEN
               iflag = -26
               RETURN
            END IF
         END IF
      ELSE
         IF (output .ne. ' ')
     1   CALL safe_open(iunit, istat, output_ext, 'old',
     1                 'formatted')
      END IF

!
!     ADDITIONAL ERROR CONTROL (necessary for parallel processing control)
!
      IF (istat .ne. 0) THEN
         PRINT * ,'Processor ',myid,': Error opening ',TRIM(output_ext),
     1         ' in STELLOPT load_physics_codes: istat = ', istat
         iflag = -2
      END IF

      END SUBROUTINE load_physics_codes
