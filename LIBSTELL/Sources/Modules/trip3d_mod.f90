!-----------------------------------------------------------------------
!     Module:        trip3d_mod
!     Authors:       S. Lazerson (lazerson@pppl.gov)
!     Date:          02/09/2015
!     Description:   This module contains routines for reading the
!                    vacuum field file generated by TRIP 3D for
!                    inclusion in the codes.
!-----------------------------------------------------------------------
      MODULE trip3d_mod
!-----------------------------------------------------------------------
!     Libraries
!-----------------------------------------------------------------------
      USE stel_kinds, ONLY: rprec
      USE safe_open_mod
      USE mgrid_mod, ONLY: nr0b, np0b, nz0b, nfper0, &
         rminb, zminb, rmaxb, zmaxb, bvac
      USE EZspline_obj
      USE EZspline
      
!-----------------------------------------------------------------------
!     Module Variables
!         
!-----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER      :: nr_trip3d, nz_trip3d, nphi_trip3d
      REAL(rprec)  :: rmin_trip3d,zmin_trip3d,phimin_trip3d,&
                      rmax_trip3d,zmax_trip3d,phimax_trip3d
      CHARACTER(LEN=256) :: filename_trip3d
      TYPE(EZspline3_r8) :: brt3d_spl, bzt3d_spl, bphit3d_spl
      
!-----------------------------------------------------------------------
!     Subroutines
!         read_trip3d:      Reads a trip3d file.
!         trip3d_to_mgrid:  Loads the trip3d data into mgrid_mod.
!         trip3d_info:      Output some information
!         trip3d_info_vmec: Output some information (for VMEC)
!         trip3d_free:      Free's memory
!-----------------------------------------------------------------------
      CONTAINS
      
      SUBROUTINE read_trip3d(filename,istat,scale_factor)
      IMPLICIT NONE
      CHARACTER(LEN=*), INTENT(in) :: filename
      REAL(rprec), INTENT(in)       :: scale_factor
      INTEGER, INTENT(inout)        :: istat
      INTEGER :: iunit, nlines, i, j, k, l
      INTEGER :: bcs1(2), bcs2(2), bcs3(2)
      REAL(rprec) :: phi_temp,r_temp,z_temp,b1_temp,b2_temp,b3_temp,&
                     b4_temp,b5_temp, pi2
      REAL(rprec), ALLOCATABLE :: phi_1d(:),r_1d(:),z_1d(:),bphi_1d(:),&
                                  br_1d(:),bz_1d(:)
      REAL(rprec), ALLOCATABLE :: br_3d(:,:,:),bphi_3d(:,:,:),bz_3d(:,:,:)
      CHARACTER(LEN=256) :: temp_str
      pi2 = 8 * ATAN(1._rprec)
      istat = 0
      nlines = 0
      ! Read File
      CALL safe_open(iunit, istat, filename, 'old', 'formatted')
      IF (istat .ne. 0) RETURN
      filename_trip3d = TRIM(filename)
      ! Read file
      READ(iunit,*) temp_str
      READ(iunit,*) temp_str
      READ(iunit,*) temp_str
      READ(iunit,*) temp_str
      READ(iunit,*) temp_str
      READ(iunit,*) temp_str
      DO 
         READ(iunit,*,IOSTAT=istat) phi_temp,r_temp,z_temp,b1_temp,b2_temp,&
                                    b3_temp,b4_temp,b5_temp
         nlines = nlines + 1
         IF (istat > 0) RETURN
         IF (istat < 0) EXIT
      END DO
      ! Allocate the arrays
      ALLOCATE(r_1d(nlines),phi_1d(nlines),z_1d(nlines),br_1d(nlines),&
            bphi_1d(nlines),bz_1d(nlines),STAT=istat)
      IF (istat /= 0) RETURN
      ! Re-read the file
      REWIND(iunit)
      READ(iunit,*) temp_str
      READ(iunit,*) temp_str
      READ(iunit,*) temp_str
      READ(iunit,*) temp_str
      READ(iunit,*) temp_str
      DO i = 1, nlines
         READ(iunit,*,IOSTAT=istat) phi_1d(i),r_1d(i),z_1d(i),bphi_1d(i),&
                                    br_1d(i),bz_1d(i),b4_temp,b5_temp
      END DO
      CLOSE(iunit)
      ! Setup Grid
      phimin_trip3d = pi2*MINVAL(phi_1d)/360
      rmin_trip3d = MINVAL(r_1d)
      zmin_trip3d = MINVAL(z_1d)
      phimax_trip3d = pi2 ! default this since we look only at tokamaks
      rmax_trip3d = MAXVAL(r_1d)
      zmax_trip3d = MAXVAL(z_1d)
      nr_trip3d = 0
      i=1
      DO
         IF (z_1d(i+1)/= z_1d(i)) EXIT
         i  = i + 1
      END DO
      nr_trip3d = i
      i=1
      DO
         IF (phi_1d(i+nr_trip3d)/= phi_1d(i)) EXIT
         i = i + nr_trip3d
      END DO
      nz_trip3d = 1 + i / nr_trip3d
      nphi_trip3d = SIZE(phi_1d)/(nr_trip3d*nz_trip3d) + 1 ! Because phi=2*pi not on grid
      ! Form 3D arrays
      ALLOCATE(br_3d(nr_trip3d,nphi_trip3d,nz_trip3d),bphi_3d(nr_trip3d,nphi_trip3d,nz_trip3d),&
               bz_3d(nr_trip3d,nphi_trip3d,nz_trip3d),STAT=istat)
      IF (istat /= 0) RETURN
      l = 1
      DO j = 1, nphi_trip3d - 1
         DO k = 1, nz_trip3d
            DO i = 1, nr_trip3d
               br_3d(i,j,k) = br_1d(l)
               bphi_3d(i,j,k) = bphi_1d(l)
               bz_3d(i,j,k) = bz_1d(l)
               l = l + 1
            END DO
         END DO
      END DO
      br_3d(:,:,nphi_trip3d) = br_3d(:,:,1)
      bphi_3d(:,:,nphi_trip3d) = bphi_3d(:,:,1)
      bz_3d(:,:,nphi_trip3d) = bz_3d(:,:,1)
      DEALLOCATE(r_1d,phi_1d,z_1d,br_1d,bphi_1d,bz_1d)
      ! Setup Splines
      bcs1=(/ 0, 0/)
      bcs2=(/-1,-1/)
      bcs3=(/ 0, 0/)
      IF (EZspline_allocated(brt3d_spl)) CALL EZspline_free(brt3d_spl,istat)
      IF (istat /= 0) RETURN
      IF (EZspline_allocated(bphit3d_spl)) CALL EZspline_free(bphit3d_spl,istat)
      IF (istat /= 0) RETURN
      IF (EZspline_allocated(bzt3d_spl)) CALL EZspline_free(bzt3d_spl,istat)
      IF (istat /= 0) RETURN
      CALL EZspline_init(brt3d_spl,nr_trip3d,nphi_trip3d,nz_trip3d,bcs1,bcs2,bcs3,istat)
      IF (istat /= 0) RETURN
      CALL EZspline_init(bphit3d_spl,nr_trip3d,nphi_trip3d,nz_trip3d,bcs1,bcs2,bcs3,istat)
      IF (istat /= 0) RETURN
      CALL EZspline_init(bzt3d_spl,nr_trip3d,nphi_trip3d,nz_trip3d,bcs1,bcs2,bcs3,istat)
      IF (istat /= 0) RETURN
      brt3d_spl%isHermite = 1
      bphit3d_spl%isHermite = 1
      bzt3d_spl%isHermite = 1
      DO i = 1, nr_trip3d
         brt3d_spl%x1(i) = rmin_trip3d + (rmax_trip3d-rmin_trip3d)*REAL(i-1)/REAL(nr_trip3d-1)
         bphit3d_spl%x1(i) = rmin_trip3d + (rmax_trip3d-rmin_trip3d)*REAL(i-1)/REAL(nr_trip3d-1)
         bzt3d_spl%x1(i) = rmin_trip3d + (rmax_trip3d-rmin_trip3d)*REAL(i-1)/REAL(nr_trip3d-1)
      END DO
      DO i = 1, nphi_trip3d
         brt3d_spl%x2(i) = phimin_trip3d + (phimax_trip3d-phimin_trip3d)*REAL(i-1)/REAL(nphi_trip3d-1)
         bphit3d_spl%x2(i) = phimin_trip3d + (phimax_trip3d-phimin_trip3d)*REAL(i-1)/REAL(nphi_trip3d-1)
         bzt3d_spl%x2(i) = phimin_trip3d + (phimax_trip3d-phimin_trip3d)*REAL(i-1)/REAL(nphi_trip3d-1)
      END DO
      DO i = 1, nz_trip3d
         brt3d_spl%x3(i) = zmin_trip3d + (zmax_trip3d-zmin_trip3d)*REAL(i-1)/REAL(nz_trip3d-1)
         bphit3d_spl%x3(i) = zmin_trip3d + (zmax_trip3d-zmin_trip3d)*REAL(i-1)/REAL(nz_trip3d-1)
         bzt3d_spl%x3(i) = zmin_trip3d + (zmax_trip3d-zmin_trip3d)*REAL(i-1)/REAL(nz_trip3d-1)
      END DO
      CALL EZspline_setup(brt3d_spl,br_3d,istat,EXACT_DIM=.true.)
      IF (istat /= 0) RETURN
      CALL EZspline_setup(bphit3d_spl,bphi_3d,istat,EXACT_DIM=.true.)
      IF (istat /= 0) RETURN
      CALL EZspline_setup(bzt3d_spl,bz_3d,istat,EXACT_DIM=.true.)
      IF (istat /= 0) RETURN
      DEALLOCATE(br_3d,bphi_3d,bz_3d)
      RETURN
      END SUBROUTINE read_trip3d

      SUBROUTINE trip3d_to_mgrid
      IMPLICIT NONE
      INTEGER :: i, j, k, l, istat, np2
      REAL(rprec) :: rval, phival, zval, pi2, br_temp, bz_temp, bphi_temp
      pi2 = 8 * ATAN(1._rprec)
      l = 1
      np2 = np0b-1
      IF (np0b == 1) np2 = 1
      DO j = 1, np0b
         DO k = 1, nz0b
            DO i = 1, nr0b
                  istat = 0
                  rval   = rminb + (rmaxb-rminb)*REAL(i-1)/REAL(nr0b-1)
                  phival = pi2*REAL(j-1)/REAL(np2*nfper0)
                  zval   = zminb + (zmaxb-zminb)*REAL(k-1)/REAL(nz0b-1)
                  CALL EZspline_isInDomain(brt3d_spl,rval,phival,zval,istat)
                  IF (istat == 0) THEN
                     CALL EZspline_interp(brt3d_spl, rval, phival, zval, br_temp, istat)
                     CALL EZspline_interp(bphit3d_spl, rval, phival, zval, bphi_temp, istat)
                     CALL EZspline_interp(bzt3d_spl, rval, phival, zval, bz_temp, istat)
                     bvac(l,1) = bvac(l,1) + br_temp
                     bvac(l,2) = bvac(l,2) + bphi_temp
                     bvac(l,3) = bvac(l,3) + bz_temp
                  END IF   
                  l = l + 1   
            END DO
         END DO
      END DO
      RETURN
      END SUBROUTINE trip3d_to_mgrid
      
      SUBROUTINE trip3d_free(istat)
      IMPLICIT NONE
      INTEGER, INTENT(out) :: istat
      istat = 0
      CALL EZspline_free(brt3d_spl,istat)
      IF (istat /= 0) RETURN
      CALL EZspline_free(bphit3d_spl,istat)
      IF (istat /= 0) RETURN
      CALL EZspline_free(bzt3d_spl,istat)
      IF (istat /= 0) RETURN
      END SUBROUTINE trip3d_free
      
      SUBROUTINE trip3d_info(iunit)
      IMPLICIT NONE
      INTEGER, INTENT(in) :: iunit
      WRITE(iunit,'(A)')   '----- TRIP3D Information -----'
      WRITE(iunit,'(A,F8.5,A,F8.5,A,I4)')   '   R   = [',rmin_trip3d,',',rmax_trip3d,'];  NR   = ',nr_trip3d
      WRITE(iunit,'(A,F8.5,A,F8.5,A,I4)')   '   PHI = [',phimin_trip3d,',',phimax_trip3d,'];  NPHI = ',nphi_trip3d
      WRITE(iunit,'(A,F8.5,A,F8.5,A,I4)')   '   Z   = [',zmin_trip3d,',',zmax_trip3d,'];  NZ   = ',nz_trip3d
      CALL FLUSH(iunit)
      RETURN
      END SUBROUTINE trip3d_info
      
      SUBROUTINE trip3d_info_vmec(iunit)
      IMPLICIT NONE
      INTEGER, INTENT(in) :: iunit
      WRITE (iunit,20) nr_trip3d, nz_trip3d, nphi_trip3d, rmin_trip3d, rmax_trip3d, &
                               zmin_trip3d, zmax_trip3d, TRIM(filename_trip3d)
 20         FORMAT(//,' TRIP3D FIELD PARAMETERS:',/,1x,24('-'),/, &
           '  nr-grid  nz-grid  np-grid      rmin      rmax      zmin', &
           '      zmax     input-file',/,3i9,4f10.3,5x,a)
      RETURN
      END SUBROUTINE trip3d_info_vmec

!-----------------------------------------------------------------------
!     End Module
!-----------------------------------------------------------------------
      END MODULE trip3d_mod
