#!/usr/bin/env python3
import sys, os
sys.path.insert(0, '../../pySTEL/')
import numpy as np                    #For Arrays
from math import pi
from libstell.beams3d import read_beams3d

try:
	qtCreatorPath=os.environ["STELLOPT_PATH"]
except KeyError:
	print("Please set environment variable STELLOPT_PATH")
	sys.exit(1)

lfail = 0
failtol = 3.0
filename='beams3d_ORBITS_slow.h5'
data=read_beams3d(filename)
if not data:
    print('ERROR Opening File: '+filename)
    sys.exit(0)

# Calc values
#rho = np.sqrt(data['S_lines'])
#rho_max = np.max(rho,axis=1)
#rho_min = np.min(rho,axis=1)
#data['delta'] = rho_max-rho_min
#x = data['R_lines']-10.0
#y = data['Z_lines']
#theta = np.arctan2(y,x)
#theta = np.where(theta > np.pi,theta-pi,theta)
#data['turning'] = np.max(theta,axis=1)
data['R0']=data['R_lines'][:,0]
data['R1']=data['R_lines'][:,1]
data['R100']=data['R_lines'][:,100]
#data['R500']=data['R_lines'][:,500]

print('BEAMS3D VERSION: ' + str(data['VERSION']))
print('==== Vectors ====')
varlist={}
#varlist['turning']=np.array([0.4270134,  1.30000282, 1.00853362, 0.91105419, 3.13805239, 1.28424185, \
# 0.63219703, 0.53907533, 1.86587054, 2.2327981,  2.5049937,  2.31536106, \
# 0.8311377,  0.94574217, 1.57115154, 1.53356953, 2.30289523, 1.51445262, \
# 1.42795221, 1.80855121, 3.12543453, 1.61452375, 1.85243264, 3.13577233, \
# 3.13918886, 3.13863239, 3.11512853, 3.138203,   3.13938066, 2.57006529, \
# 3.13437534, 3.14106569, 3.13746063, 3.14063411, 3.13657694, 3.12631134, \
# 3.13494179, 3.1363516,  3.13770466, 3.13370024])
#varlist['delta']= np.array([0.0634609,  0.11510263, 0.08012891, 0.12684286, 0.13316283, 0.13978225, \
# 0.07209561, 0.09396838, 0.11271003, 0.12254434, 0.13770218, 0.12489736, \
# 0.09306725, 0.09730119, 0.10413771, 0.10027177, 0.11936921, 0.12905228, \
# 0.10249505, 0.12127122, 0.12560551, 0.13547327, 0.12276697, 0.1261778, \
# 0.13144611, 0.11954146, 0.13844897, 0.13060579, 0.1422127,  0.13046484, \
# 0.12998523, 0.04811766, 0.14725451, 0.04874182, 0.04726258, 0.17453879, \
# 0.12138846, 0.14027319, 0.04648992, 0.15181176])
varlist['R0'] = np.array([10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5,\
 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, \
 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5, 10.5])
varlist['R1'] = np.array([10.499993,10.499976,10.49995 ,10.499913,10.499876,10.499845,10.499784, \
 10.499725,10.499668,10.499595,10.499498,10.499407,10.499345,10.499216, \
 10.499128,10.498982,10.498882,10.498773,10.498641,10.498504,10.498285, \
 10.498209,10.498053,10.497828,10.497679,10.497522,10.497377,10.497145, \
 10.496948,10.496834,10.496608,10.496386,10.496202,10.496011,10.495805, \
 10.495634,10.495307,10.495127,10.494906,10.494667])
varlist['R100'] = np.array([10.511974,10.496885,10.5041  ,10.489401,10.48416 ,10.485559,10.465555, \
 10.484323,10.36921 ,10.500351,10.464425,10.407678,10.49449 ,10.337584, \
 10.376809,10.149902,10.373562,10.348876,10.140087,10.168241,10.001694, \
 10.031635, 9.962286, 9.938457, 9.852885, 9.731119, 9.780712, 9.889805, \
 10.135317,10.019791,10.115431,10.401325, 9.681586, 9.809915, 9.496002, \
 10.248991, 9.499636, 9.800984,10.296117, 9.94482 ])
#varlist['R500'] = np.array([10.54277998, 10.57196712, 10.27044819, 10.37134606, 10.36949525, 10.36275332, \
# 10.53850064, 10.51174778, 10.06890164, 10.4471823,  10.42614472, 10.48604785, \
# 10.46567,    10.38794642, 10.00457241, 10.44508214, 10.48880624, 10.41658241, \
# 10.47249319,  9.96727961,  9.52727141, 10.28322166, 10.58856652,  9.74404286, \
#  9.70036853, 10.23995058,  9.72115835,  9.49246235, 10.51031916, 10.38976587, \
#  9.62317718, 10.07464268,  9.67119336, 10.49999564,  9.81744224, 10.04807668, \
#  9.50293593, 10.06782083,  9.98882236,  9.50144957])

for temp in varlist:
    act = varlist[temp]
    cal = data[temp]
    #print(np.array2string(cal,precision=6, separator=','))
    cal = np.where(act==0,0,cal)
    div = np.where(act==0,1,act)
    perct = 100*sum(abs(act-cal)/div)
    perct = 100*np.sqrt(sum((act-cal)**2)/len(act))/np.mean(act) #normalized root mean squared deviation
    print(f'  {temp}: {cal[0]:.4f}   {act[0]:.4f}   {perct:.2f}%')
    if perct > failtol:
        lfail = 1
print('=================')

if (lfail):
    print('  STATUS: FAIL!!!!!')
else:
    print('  STATUS: PASS')

sys.exit(0)




